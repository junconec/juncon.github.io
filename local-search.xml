<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么才算是真正的编程能力？</title>
    <link href="undefined2020/05/21/%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%EF%BC%9F/"/>
    <url>2020/05/21/%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="什么才算是真正的编程能力？"><a href="#什么才算是真正的编程能力？" class="headerlink" title="什么才算是真正的编程能力？"></a>什么才算是真正的编程能力？</h3><p>计算机科学有两类根本问题。一类是理论：算法，数据结构，复杂度，机器学习，模式识别，等等等。一类是系统：操作系统，网络系统，分布式系统，存储系统，游戏引擎，等等等等。</p><p>理论走的是深度，是在追问在给定的计算能力约束下如何把一个问题解决得更快更好。而系统走的是广度，是在追问对于一个现实的需求如何在众多的技术中设计出最多快好省的技术组合。</p><p>搞ACM的人，只练第一类。像你这样的更偏向于第二类。其实挺难得的，但很可惜的是第二类能力没有简单高效的测量考察方法，不像算法和数据结构有ACM竞赛，所以很多系统的苗子都因为缺少激励和正确引导慢慢就消隐了。</p><p>所以比尔盖茨才会说，看到现在学编程的人经常都把编程看作解各种脑筋急转弯的问题，他觉得很遗憾。</p><p>做系统，确实不提倡“重复发明轮子”。但注意，是不提倡“重复发明”，不是不提倡“重新制造”。恰恰相反的，我以为，系统的编程能力正体现在“重新制造”的能力。</p><p>能把已有的部件接起来，这很好。但当你恰好缺一种关键的胶水的时候，你能写出来吗？当一个已有的部件不完全符合你的需求的时候，你能改进它吗？如果你用的部件中有bug，你能把它修好吗？在网上繁多的类似功能的部件中，谁好谁坏？为什么？差别本质吗？一个开源代码库，你能把它从一个语言翻译到另一个语言吗？从一个平台移植到另一个平台吗？能准确估计自己翻译和移植的过程需要多少时间吗？能准确估计翻译和移植之后性能是会有提升还是会有所下降吗？</p><p>系统编程能力体现在把已有的代码拿来并变成更好的代码，体现在把没用的代码拿来并变成有用的代码，体现在把一个做好的轮子拿来能画出来轮子的设计蓝图，并用道理解释出设计蓝图中哪些地方是关键的，哪些地方是次要的，哪些地方是不容触碰的，哪些地方是还可以改进的。</p><p>如果你一点不懂理论，还是应该学点的。对于系统性能的设计上，算法和数据结构就像在自己手头的钱一样，它们不是万能的，但不懂是万万不行的。</p><p>怎么提高系统编程能力呢？土办法：多造轮子。就像学画画要画鸡蛋一样，不是这世界上没有人会画鸡蛋，但画鸡蛋能驯服手指，感受阴影线条和笔触。所以，自己多写点东西吧。写个编译器？渲染器？操作系统？web服务器？web浏览器？部件都一个个换成自己手写的，然后和已有的现成部件比一比，看看谁的性能好，谁的易用性好？好在哪儿？差在哪儿？为什么？</p><p>更聪明一点的办法：多拆轮子。多研究别人的代码是怎么写的。然而这个实践起来经常很难。原因：大部分工业上用的轮子可能设计上的思想和技术是好的，都设计和制造过程都很烂，里面乱成一团，让人乍一看毫无头绪，导致其对新手来说非常难拆。这种状况其实非常糟糕。所以，此办法一般只对比较简单的轮子好使，对于复杂的轮子，请量力而行。</p><p>轮子不好拆，其实是一个非常严重的问题。重复发明轮子固然是时间的浪费，但当轮子复杂而又不好拆的时候，尤其是原来造轮子的人已经不在场的时候，重新发明和建造轮子往往会成为无奈之下最好的选择。这是为什么工业界在明知道重复发明/制造轮子非常不好的情况下还在不断重复发明/制造轮子的根本原因。</p><p>程序本质是逻辑演绎的形式化表达，记载的是人类对这个世界的数字化理解。不能拆的轮子就像那一篇篇丢了曲谱的宋词一样，能读，却不能唱。</p><p>鄙人不才，正在自己研究怎么设计建造一种既好用又好拆的轮子。您没那么幸运，恐怕是等不到鄙人的技术做出来并发扬光大了。在那之前，多造轮子，多拆好拆的小轮子，应该是提高编程能力最好的办法了。</p>]]></content>
    
    
    <categories>
      
      <category>浅谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于爬虫的几种常见的反爬</title>
    <link href="undefined2019/12/24/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%8D%E7%88%AC/"/>
    <url>2019/12/24/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%8D%E7%88%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="1-基于useragent反爬"><a href="#1-基于useragent反爬" class="headerlink" title="1.基于useragent反爬"></a>1.基于useragent反爬</h4><p>思想：服务器后台对访问的User_Agent进行统计，单位时间内同一User_Agent访问的次数超过特定的阀值，则会被不同程度的封禁IP，从而造成无法进行爬虫的状况。</p><p>我提供给大家两种方案，</p><p><strong>方案</strong>一：</p><p>将常见的User-Agent封装到一个.py文件中，命名为useragent.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表存储不同的User-Agent,这里仅示例三个,详情可百度百度搜索,链接在代码下方</span></span><br><span class="line">ua_list = [<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1'</span>,</span><br><span class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0'</span>,</span><br><span class="line">            <span class="string">'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3)'</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>他人为我们总结的常用User-Agent获取链接：<a href="https://www.cnblogs.com/zrmw/p/9332801.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrmw/p/9332801.html</a></p><p>在爬虫过程中导入useragent.py文件，随机选择ua_list中的user-agent。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 导入自己定义的useragents.py中的ua_list</span></span><br><span class="line"><span class="keyword">from</span> .useragents <span class="keyword">import</span> ua_list</span><br><span class="line"><span class="comment">#随机获取User-Agent</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:random.choice(ua_list)&#125;</span><br><span class="line">req = request.Request(</span><br><span class="line">            url=<span class="string">'https://...'</span>,</span><br><span class="line">            headers=headers</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong><br>Python中加载fake_useragent库，随机生成User-Agent添加到headers中。<br>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="comment"># 测试fake-useragent</span></span><br><span class="line">ua = UserAgent()</span><br><span class="line">print(ua.random)</span><br></pre></td></tr></table></figure><p>####2.基于IP反爬机制</p><p>思想：后台服务器对访问进行统计，单位时间内同一IP访问的次数超过一个特定的值（阀值），就会不同程度的禁封IP，导致无法进行爬虫操作。</p><p>解决方案<br>使用不同的IP地址进行访问，设置一定的访问时滞，例：random.sleep(3)。<br>本文分享给大家一种常见的方法，基于西刺代理购买的专业代理构建可用代理池。经常爬虫的伙伴应该对西刺代理并不陌生，可以免费或花钱购买可用的IP地址，但是怎么说呢，免费的很多都不能用，（其实收费的也有很多不能用，所以感觉有点小坑。）<br>西刺代理网址：<a href="https://www.xicidaili.com/" target="_blank" rel="noopener">https://www.xicidaili.com/</a></p><h4 id="3-动态抓包"><a href="#3-动态抓包" class="headerlink" title="3.动态抓包"></a>3.动态抓包</h4><p>思想：当我们进入某个网页时，我们想通过查看源代码解析页面结构，看到的内容却不是我们网页显示的内容；或者，在我们浏览网站时网页结构显示不全，只有滑动鼠标时才能将剩余的信息显示出来，我们就需要靠手动抓包来解析不同。</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>反爬</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>python，反爬</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>少儿编程教研必备</title>
    <link href="undefined2019/12/01/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B%E6%95%99%E7%A0%94/"/>
    <url>2019/12/01/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B%E6%95%99%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h2 id="个人认为做少儿编程教研需要具备的思考维度"><a href="#个人认为做少儿编程教研需要具备的思考维度" class="headerlink" title="个人认为做少儿编程教研需要具备的思考维度"></a>个人认为做少儿编程教研需要具备的思考维度</h2><p><strong>首先是懂编程</strong>，有不错的编程基本功，这一点很好理解。少儿编程教育虽然不是为了把孩子培养成小程序员，但毕竟要对孩子进行编程启蒙，教会孩子一些基础的编程概念和算法知识。如果候选人本身有不错的编程基本功，是非常有利于他快速掌握Scratch这门语言，快速上手工作的。当然，我们并不要求候选人的编程基础达到程序员那样的程度。</p><p><strong>第二点也很重要，懂教育或者懂孩子</strong>。这一点看上去很宽泛，简单来说，就是候选人能够用孩子能听懂的语言教会孩子编程，同时让孩子爱上编程。自己会编程，和教会别人编程（尤其是教会小学生编程），是很不一样的能力。前者要求自己逻辑能力好，聪明，而后者，则要求你抛弃自己“编程专家”的视角，切换到一个初学者视角，从孩子不太聪明的视角去思考，感受他的困惑点，然后把这些卡点掰扯清楚。一般来说，如果候选人当过老师或者有一些教育学基础，或者很了解孩子的特性，对他切换视角是很有帮助的。另外更重要的是，要能够把自己对编程的热情传递给孩子，恰当地鼓励孩子，让孩子保持对编程的兴趣，这比教会孩子多少编程知识都要重要。</p><p><strong>第三点是产品/数据素养</strong>，可能很多人好奇为什么会有这一点，其实这点更偏向于附加要求。现在很多少儿编程课都是在线课程，而且都在一步步产品化。以核桃编程为例，<em>课程是剧情+游戏闯关的形式</em>，每个关卡挑战都可以理解成是一个小产品demo，如果候选人有产品方面的经验或者基本素养，能够关注到用户体验，在实际设计课程时，在关卡的玩法策划，视觉审美、孩子的操作体验上都能提出很好的建议。同时，评判一节在线教育课程，除了由有经验的教研主观判断外，更多地会结合学生学习行为数据去分析。如果候选人有数据分析方面的经验或方法论，有利于工作时更客观地从数据维度去评价一个课程的好坏，分析出课程哪里有问题，并提出如何修改的意见，这也是很大的加分项。</p><p>说完岗位的能力模型，我们再根据这个反推，如果你是一名求职者可以做哪些准备。下面根据候选人的不同背景情况，具体分析。</p><p>第一种情况，有编程基础但没有教育基础，如程序员、计算机相关专业的毕业生等。</p><p>对于这种情况，编程能力一般不会是求职障碍，怎么能够具有初学者视角，有一些基本的教育认知，是比较大的挑战。怎么克服自己已经固化的“编程专家”视角，最好的莫过于亲自当几次老师试试。如果身边有适龄的小朋友，可以尝试着教几节入门编程课，在这几节课的过程中，你就会不断地去琢磨怎么讲得更容易让小朋友听懂，而孩子在听课过程中那稚嫩又困惑的表情，又会一直提醒你，不要从自己的角度去讲解。这种实践，对你切换视角是有很直接的帮助的。</p><p>怎么才能知道自己有没有初学者视角呢？这里可以做个最简单的小测试，问问自己怎么给一个三年级的小朋友解释清楚变量这个概念，如果你还在纠结“存储空间”“赋值”这些术语，说明你还没有转变思路，如果你开始用“一个盒子“或生活中的容器来打比喻，说明已经在转变固有思路了。</p><p>如果自己没有实践的条件，可以找找一些兼职机会当个少儿编程助教，看看其他老师是怎么上课的，在观摩的过程中多思考多记录。与此同时，自己可以看一些对课程设计有帮助的书，比如<strong>《人是如何学习的》《重理解的课程设计》</strong>，着手了解一些基本的教育学原理，如皮亚杰关于儿童的认知发展理论和建构主义理论等，提前做一些教育知识方面的储备。</p><p>准备的时候，除了补短，还可以 扬长。既然编程有优势，那就多发挥优势，可以快速学习Scratch达到不错的水平；可以针对一些常见的编程概念设计一些教学案例；可以了解一下少儿编程完整的课程体系，从专业方面提出自己的思考。</p><p>第二种情况，有教育背景但没有编程基础，如其他学科的教研/老师，教育师范生等。</p><p>这种情况的优势是对于教育、孩子特点已经有一定的认知，面临的卡点也很明显，自己对于编程无基础无认知，何谈把它教给学生。但其实这种背景的候选人，如果准备得当，反而能够获得一个大家容易忽视的优势。这时候，开始自学编程是必备准备，而用Scratch语言入门是很不错的选择。候选人以一个初学者的身份，能够更好地了解初学者学编程碰到的一些困惑，把这些困惑、卡点详细地记录下来，仔细地思考编程为什么难，这对于后期的教研工作帮助很大，这段经历反而变成一种优势。</p><p>另外，自己在教学工作中，一定要多思考多输入，去思考学生的发展特点，去接触不同类型的学生，让教学真正变成自己的长处，而不是对着已经准备好的教学大纲照本宣科，那这种“老师”基本不具备教育背景方面的优势。</p><p>第三种，有产品或数据方面的工作经历，但基本无编程或教育基础。如，产品经理或需要数据分析的岗位。</p><p>这种情况在准备时可以扬长避短，在面试时强调自己产品/数据分析方面的优势，并思考如何应用在教研工作中，毕竟这种背景的候选人在教研或师资队伍里是比较少的，可以作为团队一个很好的补充。</p><p>同时，也可以参照上面两种情况，针对性地做一些准备。最好可以自己一边学习编程，一边把学到的知识教给小朋友，实践“费曼学习法”。</p><p>第四种，背景完全不沾边，如不相关专业的应届毕业生，或者其他行业想转行的人。</p><p>这种背景，老实讲在面试时肯定是不占优势的，所以需要做的准备更多，但落选的概率也不小。除了前面提到的几点工作可以准备外，还可以考虑曲线救国，一般教育公司除了教研岗外，还有授课教师岗或者辅导老师岗，其中有一些老师岗位，要求没有那么高，候选人可以根据自身条件，看看是不是先从老师岗位入手，积累一些教学经验，再择机转岗教研，这也是一个思路。</p>]]></content>
    
    
    <categories>
      
      <category>浅谈少儿编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈少儿编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>少儿编程三问</title>
    <link href="undefined2019/10/21/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B-1/"/>
    <url>2019/10/21/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<p>今天无意当中看到了我弟弟的卷子中既然出现了编程题，勾起了我的兴趣并对这个行业并做了一些调查，有了一种转行做少儿编程的冲动</p><p>自从孩子上了初中，孩子妈就开始盯着各种真假难辨的中考、高考新政传言。当她从铺天盖地的少儿编程广告里获悉，编程将纳入中考，高考范围，并且2018年高考，多个省份的数学卷甚至都出现了编程题时，就变得异常兴奋。我这个写了近20年代码，家庭地位本来十分低下的资深码农，一夜之间变身“宝藏男孩”。</p><p>中考、高考政策一天一个新花样，谁也不知道将来要不要考编程。不过2018年，江苏省、天津市、北京市等省份高考数学卷出现了编程题倒是真的。所以，即使一直反对少儿学编程，我也不得不认真思考</p><p>​    少儿学编程有没有必要？</p><p>​    花多长时间学编程上，才不会影响主课学习时间？</p><p>​    怎么教，才能避免借口学编程，实际玩游戏？</p><h3 id="少儿编程三问"><a href="#少儿编程三问" class="headerlink" title="少儿编程三问"></a>少儿编程三问</h3><p><strong>少儿学编程有没有必要</strong></p><p>​    编程语言也是一种语言，只不过打交道的是电脑而已。</p><p>​    学语言，一般都会有两个很深的体会。</p><p>​    有使用环境，学起来快，比如语文；没有使用环境，学起来痛苦，比如英语。</p><p>​    会用和用得好完全是两回事。《新华字典》背得滚瓜烂熟也不一定能写出好文章。</p><p>​    学编程和学别的语言一样，只学不用，不仅学得很辛苦，如果不用，还忘得快。少儿学编程，即使死记硬背把语法都记住了，生活中没有使用的场景，渐渐也会都忘光。这也是我之前一直反对少儿学编程的主要原因。</p><p>​    但学编程又和学别的语言不完全一样。能不能写出好作文，更多是看天赋：情感细腻、想象力丰富，有同理心……；但能不能写出好程序，却是可以培训和锻炼的。</p><p><strong>程序的核心是算法，算法的本质是数学。</strong></p><p>​    就像2018年各省高考数学卷里的编程题，表面上看是编程题，实际上考察的还是数学上的逻辑思维能力。所以，少儿学编程，关键要看学的是什么。</p><p>​    死记硬背语法，或者拖拽几个小方块，快速做出一个小游戏。开始兴致盎然，但兴头一过，用不了多久就忘得差不多了。</p><p>​    但如果能学的是编程里最有价值的东西，数学逻辑和解决问题的思维方式。不仅高考用得着，以后工作、生活中都用得着。</p><p><strong>花多长时间学编程</strong> </p><p>​    孩子学习压力已经够重了，即使学编程有好处。但是花费大量的时间，性价比高吗？会不会得不偿失，反而影响了主课的学习？</p><p>  这种担忧的本质是：主课学习和编程学习是对立的。</p><p>​    但假设我们学习编程的方式是：</p><p>​    每周大约30分钟。围绕的是一个数学或者逻辑思维问题。</p><p>​    20分钟用来思考、讨论、写写画画，电脑都不需要打开。</p><p>​    10分钟用来教可以用来解决这个问题的编程知识，程序只是一个工具，帮助我们提高解决问题的效率。</p><p>​    不能说完全消除了两者的对立，但至少每周花的时间不多，大多数时间是花在逻辑思考上，顺便学会了编程。</p><p><strong>怎么教，不会让学编程变成玩游戏</strong></p><p>​    80后家长应该都记得“小霸王”学习机，当年几乎每个小孩人手一台。号称也是用来学电脑，学编程的。但实际上，差不多都用来玩游戏了。“魂斗罗”、“坦克大战”，……是我们最美好的童年回忆之一，甚至连“之一”都没有。</p><p>怎么让学编程不成为玩游戏的借口，说实话是一个巨大的挑战。我的实践经验是：</p><p>​    ● <strong>每周的题目足够有趣</strong>。找到足够多有趣，能引发孩子思考，又能由易到难把编程语言知识点成体系串联起来的题目，是最大的挑战。</p><p>​    ● <strong>父母的参与</strong>。这些题目都是不借助电脑也能做的，前20分钟父母一起参与讨论，思考，不仅能让孩子更投入，也能增进和孩子的感情。这也是我把公众号取名“和孩子一起学Python”的初衷。</p><p>​    ● <strong>尽可能减少电脑操作的时间</strong>。思路理顺之后，需要电脑操作的时间不多，完全可以控制孩子用电脑的时间，像我家小朋友是个小近视，每周用电脑的时间要求她不能超过1个小时。</p>]]></content>
    
    
    <categories>
      
      <category>浅谈少儿编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈少儿编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短信服务与邮件服务</title>
    <link href="undefined2019/08/26/%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"/>
    <url>2019/08/26/%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>短信和邮件是开发过程中必不可少的工具</p><p>短信服务</p><p>短信服务常用于通知提醒、验证码、营销推广、服务器报警、短信轰炸机等。。。</p><p>短信服务需要借助第三方服务商来完成，不同的服务商，短信到达率是不一样的，这里使用云片来完成短信服务</p><p>邮件服务  使用自带的邮件服务即可</p><p><strong>发送短信</strong>    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://www.yunpian.com/api/sms.html#c8   api说明</span></span><br><span class="line"><span class="comment">#https://www.yunpian.com/dashboard/domestic/register#!/domestic/register/tpl 模板签名</span></span><br><span class="line"><span class="comment">#账号13811928431  密码zc85011</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> quote</span><br><span class="line"><span class="comment">#短信模板【xxx】#name#您好 现在室外温度:#wendu# 室外湿度:#shidu#</span></span><br><span class="line"><span class="comment">#参数说明  name 发送短信模板的姓名 wendu 温度  shidu 湿度  iphone 电话号码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsg</span><span class="params">(name,wendu,shidu,iphone)</span>:</span></span><br><span class="line"><span class="comment">#验证码模板</span></span><br><span class="line"><span class="comment">#test_data = &#123;'apikey':'de83447f8d0f16bff95a2c151803addf','mobile':'13811928431','text':'【xxx】您的验证码是1234'&#125;</span></span><br><span class="line"><span class="comment">#quote 是转换urlencode字符串的</span></span><br><span class="line">    tplvalue = quote(<span class="string">"#name#"</span>) + <span class="string">"="</span> + quote(name) + <span class="string">"&amp;"</span> + quote(<span class="string">"#wendu#"</span>) + <span class="string">"="</span> + quote(wendu)+<span class="string">"&amp;"</span> + quote(<span class="string">"#shidu#"</span>) + <span class="string">"="</span> + quote(shidu);</span><br><span class="line">    <span class="comment">#'tpl_id':'2138996'固定的</span></span><br><span class="line">    test_data = &#123;<span class="string">'apikey'</span>:<span class="string">'de83447f8d0f16bff95a2c151803addf'</span>,<span class="string">'mobile'</span>:iphone,<span class="string">'tpl_id'</span>:<span class="string">'2138996'</span>,<span class="string">'tpl_value'</span>:tplvalue&#125;</span><br><span class="line">    test_data_urlencode = urllib.urlencode(test_data)</span><br><span class="line">    requrl = <span class="string">"https://sms.yunpian.com/v1/sms/tpl_send.json"</span></span><br><span class="line">    req = urllib2.Request(url = requrl,data =test_data_urlencode)</span><br><span class="line">    <span class="keyword">print</span> req</span><br><span class="line">    res_data = urllib2.urlopen(req)</span><br><span class="line">    res = res_data.read()</span><br><span class="line">    <span class="keyword">print</span> res</span><br><span class="line">    <span class="comment">#https://www.yunpian.com/api/sms.html</span></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">sendMsg(<span class="string">'张同学'</span>,<span class="string">'34'</span>,<span class="string">'12'</span>,<span class="string">'138119283'</span>)</span><br></pre></td></tr></table></figure><p><strong>邮件服务</strong>    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="comment"># 第三方 SMTP 服务</span></span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMessage</span><span class="params">(subject,content)</span>:</span></span><br><span class="line">    mail_host = <span class="string">"smtp.itcast.cn"</span>  <span class="comment"># 设置服务器</span></span><br><span class="line">    mail_user = <span class="string">"zhangcheng@itcast.cn"</span>  <span class="comment"># 用户名</span></span><br><span class="line">    mail_pass = <span class="string">"z850311"</span>  <span class="comment"># 口令</span></span><br><span class="line">    sender = <span class="string">'z@163.com'</span><span class="comment">#好像什么都行</span></span><br><span class="line">    receivers = [<span class="string">'z@163.com'</span>]  <span class="comment"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></span><br><span class="line">    <span class="comment">#组装数据</span></span><br><span class="line">    str= <span class="string">'大家好\n我是逗比机器人，在群里有人@了我们，提出了问题'</span></span><br><span class="line">    message = MIMEText(str, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'From'</span>] = formataddr([<span class="string">"MyQQRot"</span>, <span class="string">"zz@163.com"</span>])</span><br><span class="line">    <span class="comment">#拼接多人</span></span><br><span class="line">    message[<span class="string">'To'</span>] = <span class="string">','</span>.join(receivers)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line">    smtpObj = smtplib.SMTP()</span><br><span class="line">    smtpObj.connect(mail_host, <span class="number">25</span>)  <span class="comment"># 25 为 SMTP 端口号</span></span><br><span class="line">    smtpObj.login(mail_user, mail_pass)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    print(<span class="string">"邮件发送成功"</span>)</span><br></pre></td></tr></table></figure><p><strong>发送邮件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(&apos;邮件主题&apos;,&apos;邮件测试&apos;)</span><br></pre></td></tr></table></figure><p><strong>邮件服务</strong>    2（3行代码搞定）</p><p>话不多说上来先看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yagmail</span><br><span class="line">yag = yagmail.SMTP(user=<span class="string">'user@163.com'</span>,password=<span class="string">'1234'</span>,host=<span class="string">'smtp.163.com'</span>) <span class="comment">#注意这个password是你授权密码</span></span><br><span class="line">contents = [<span class="string">'这里是内容'</span>]</span><br><span class="line">yag.send(<span class="string">'target@qq.com'</span>,<span class="string">'主题：这是一个主题'</span>,contents)</span><br></pre></td></tr></table></figure><p><strong>yagmail.SMTP()参数</strong></p><p>yagmail.SMTP()里面的几个重要参数！user和password顾名思义啦，就是你自己的邮箱账号和密码<br>但是这个问题就来了，我们平时登陆邮箱一般账号密码登陆有些时候好像是要打验证码的呀，这样python就传了个账号和密码真的能把邮件发出去吗？然鹅此密码非彼密码，用的密码是邮箱中的授权码，就是专门授权给机器登陆的密码。一般邮箱中，进入设置，然后POP3/SMTP/IMAP设置，打开服务就可以设置授权码了。</p><p>send（）参数</p><p><img src="/Users/juncone/Desktop/Snip20191005_22.png" srcset="/img/loading.gif" alt="nip20191005_2"></p><p>args.to 是收件人邮箱（给多个目标发邮件只需创建一个列表，将邮箱放在列表中即可）</p><p>args.subject 是主题</p><p>args.contents 是邮箱正文</p><p>args.attachments 是附件(传入文件路径)</p>]]></content>
    
    
    <categories>
      
      <category>smscode</category>
      
      <category>sendemail</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>短信与邮件服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python源码解释过程</title>
    <link href="undefined2019/08/26/python%E6%BA%90%E7%A0%81%E8%A7%A3%E9%87%8A%E8%BF%87%E7%A8%8B/"/>
    <url>2019/08/26/python%E6%BA%90%E7%A0%81%E8%A7%A3%E9%87%8A%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">首先你可以观察一下程序的运行过程，具体步骤如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、编写py文件 A</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、在编写一个py文件 B</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、在A中<span class="keyword">import</span> B</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、运行py文件A</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">在运行py文件A的时候，会产生一个B的pyc文件，加速装载，但是A在每次使用的时候，由于只装载一次，所以没有pyc</span><br><span class="line"></span><br><span class="line">以上是对<span class="keyword">import</span>解释</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">整体过程解释</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Python先把代码（.py文件）编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 字节码</span><br><span class="line"></span><br><span class="line">字节码在Python虚拟机程序里对应的是PyCodeObject对象。</span><br><span class="line"></span><br><span class="line">.pyc文件是字节码在磁盘上的表现形式。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> pyc文件</span><br><span class="line"></span><br><span class="line">PyCodeObject对象的创建时机是模块加载的时候，即<span class="keyword">import</span>。</span><br><span class="line"></span><br><span class="line">Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</span><br><span class="line"></span><br><span class="line">如果test.py加载了其他模块，如<span class="keyword">import</span> util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</span><br><span class="line"></span><br><span class="line">如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</span><br><span class="line"></span><br><span class="line">加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql_docker_groupby</title>
    <link href="undefined2019/08/25/mysql-docker-groupby/"/>
    <url>2019/08/25/mysql-docker-groupby/</url>
    
    <content type="html"><![CDATA[<h1 id="Mac下mysql5-7-group-by报错问题"><a href="#Mac下mysql5-7-group-by报错问题" class="headerlink" title="Mac下mysql5.7 group by报错问题"></a>Mac下mysql5.7 group by报错问题</h1><p>在Mac下执行分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tagtable group by categroy order by numid</span><br></pre></td></tr></table></figure><p>分组会出现错误</p><p>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘student.student2.id’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</p><p>mac中安装的mysql默认是没有配置文件的，我们要做的就是</p><p>进入数据库查看sqlmodel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/bin./mysql -uroot -pselect @@global.sql_mode;</span><br></pre></td></tr></table></figure><p>如果有only_full_group_by这个模式，你继续往下看</p><p>先关闭mysql服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/support-files/mysql.server stop</span><br></pre></td></tr></table></figure><p>如果出错没停止，就从偏好设置里面关掉它</p><p>然后将support-files文件夹下my-default.cnf内容添加一行，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql_mode=&quot;&quot;</span><br></pre></td></tr></table></figure><p>保存，然后copy到目录/etc/下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp   /usr/local/mysql/support-files/my-default.cnf  /etc/my.cnf</span><br></pre></td></tr></table></figure><p>然后启动mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure><p>在执行就无错了</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-21-%E4%B8%8B%E5%8D%8812.38.59-1024x478.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql_Ubuntu</title>
    <link href="undefined2019/08/25/mysql-Ubuntu/"/>
    <url>2019/08/25/mysql-Ubuntu/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下安装mysql、ssh、jupyter"><a href="#Ubuntu下安装mysql、ssh、jupyter" class="headerlink" title="Ubuntu下安装mysql、ssh、jupyter"></a>Ubuntu下安装mysql、ssh、jupyter</h1><p>安装mysql**</p><p>sudo apt-get install mysql-server</p><p>输入密码MyNewPass4!</p><p>sudo apt-get install mysql-client</p><p>sudo apt-get install libmysqlclient-dev</p><p>sudo service mysql start</p><p>sudo netstat -tap |grep mysql</p><p>mysql -u root -p</p><p>输入密码 MyNewPass4!</p><p>修改外部访问权限</p><p>mysql&gt;use mysql;</p><p>mysql&gt;update user set host =’%’ where user=’root’</p><p>mysql&gt;select host,user from user;</p><p>mysql&gt;exit</p><p>mysql下不存在sql_mode问题</p><p>重启</p><p>sudo service mysql restart</p><p>安装ssh</p><p>sudo apt-get update</p><p>sudo apt-get install openssh-server</p><p>sudo service ssh start</p><p>sudo ps -e |grep ssh</p><p>可以查看到sshd已经启动了</p><p>jupyter是依赖python环境的</p><p>sudo apt-get install python3-pip</p><p>sudo pip3 install –upgrade pip</p><p>sudo pip3 install jupyter</p><p>测试 jupyter notebook –ip=127.0.0.1</p><p>以上是可以的，但是外部无法访问，需要修改其中的配置</p><p>jupyter notebook –generate-config</p><p>就会在个人用户目录下生成.jupyter jupyter_notebook_config.py</p><p>vim ~/.jupyter/jupyter_notebook_config.py</p><p>修改里面的配置信息,在大约26%位置</p><p>#c.NotebookApp.ip= ‘localhost’</p><p>修改以上配置为以下内容</p><p>c.NotebookApp.ip=’*’</p><p>Ubuntu下启动命令为</p><p>jupyter notebook  –ip=0.0.0.0 </p><p>如果要在脚本中运行，还需要增加参数</p><p>jupyter notebook  –ip=0.0.0.0 –allow-root</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>Bug</tag>
      
      <tag>mysql+ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql忘记密码解决方法</title>
    <link href="undefined2019/07/23/mysql/"/>
    <url>2019/07/23/mysql/</url>
    
    <content type="html"><![CDATA[<p>mysql 解决忘记密码问题</p><p>mac下mysql 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:</p><p>新入了mac pro，安装好mysql后，用终端进入mysql遇到个问题： 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: N</p><p>讲道理，我还设密码呢，但是第一次进来就报错，goo了一下大概原因可能是mysql创建的时候给自动分配了密码。</p><p>不管分配没分配密码，反正一般的解决方法就是：先跳过验证，再重设密码。</p><p>具体步骤：</p><ol><li><p>先关闭MySQL服务；<br>执行</p><p> sudo /usr/local/mysql/support-files/mysql.server stop</p></li></ol><p>或者在系统偏好设置中关闭MySQL服务(如果电脑有设置密码的，此处会要求输入计算机密码)</p><p>2.去mysql文件夹里设置跳过验证（3步）</p><pre><code>先进入mysql文件夹：cd /usr/local/mysql/bin/设置权限，如果电脑有设置密码（开机和解锁计算机时要求输入的那个密码），在输入此句后会要求输入密码。输入密码后按回车确认sudo su跳过验证./mysqld_safe --skip-grant-tables &amp;</code></pre><p>3.开始设置我们自己的新密码</p><p>打开一个新的终端，输入</p><pre><code>/usr/local/mysql/bin/mysql -u root -p</code></pre><p>然后会要求输入密码，因为此时根本没有密码，所以直接点确认，显示以下信息表示成功进入mysql(与windows系统一样)</p><pre><code>Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 20Server version: 5.7.11Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; </code></pre><p>现在设置新密码，注意要打引号：</p><pre><code>UPDATE mysql.user SET authentication_string=PASSWORD(&apos;cc77&apos;) where User=&apos;root&apos;;</code></pre><p>回车确认，显示以下信息表示修改密码成功</p><pre><code>Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 1</code></pre><p>然后刷新一下，让上述修改生效：</p><pre><code>flush privileges;</code></pre><p>刷新成功会显示以下信息：</p><pre><code>Query OK, 0 rows affected (0.01 sec)</code></pre><p>4.重启mysql,用新密码登录，可以登录成功了。但是进行其他mysql操作，会显示：</p><p>ERROR 1820 (HY000) :You must reset your password using AlTER USER statement before executing this statement.</p><p>意思是还要再重设一遍密码，直接输入：</p><pre><code>SET PASSWORD = PASSWORD(&apos;cc77&apos;);</code></pre><p>修改成功后，终端会显示：</p><pre><code>Query OK, 0 rows affected, 1 warning (0.01 sec)</code></pre><p>至此，修改密码彻底完成，可以做任何相关sql操作了</p>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>Bug</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫+selenium</title>
    <link href="undefined2018/12/03/selenium%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>2018/12/03/selenium%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>爬虫使用selenium进行爬取，借助chrome进行调试，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver browser = webdriver.Chrome()browser.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure><p>你会欣喜若狂的运行一下，如果你是初次使用，会报错，需要下载一个webdriver的文件，这个文件要放在chrome浏览器下，最坑的是这个文件需要对应你的浏览器版本才可以</p><p>可以访问以下地址查看对应</p><p><a href="https://blog.csdn.net/huilan_same/article/details/51896672" target="_blank" rel="noopener">https://blog.csdn.net/huilan_same/article/details/51896672</a></p><p>1、windows下找chrome的安装位置</p><p>2、mac下找chrome.app</p><p>右键显示包内容,实际上这个文件<a href="http://47.93.248.15/wp-content/uploads/2018/05/chromedriver.zip" target="_blank" rel="noopener">chromedriver</a> 在最新的mac上，需要在/usr/local/bin下也弄一份同样的文件，这样还不够，还需要赋值权限chmod 777 /xxxx/xxxx/xxx/chromedriver才可以</p><p>3、linux下找到安装位置</p><p>以下是对应的chrome的工具，需要根据版本选择对应的工具</p><p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>版本编号从2.0-2.38之间，截稿前最新版本是2.33,但是需要注意不是最新的就是能用的，要找到你对应，怎么找对应的</p><p>点击每个版本里面，都有一个notes.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------ChromeDriver v2<span class="number">.38</span> (<span class="number">2018</span><span class="number">-04</span><span class="number">-17</span>)----------</span><br><span class="line">Supports Chrome v65<span class="number">-67</span></span><br><span class="line">----------ChromeDriver v2<span class="number">.37</span> (<span class="number">2018</span><span class="number">-03</span><span class="number">-16</span>)----------</span><br><span class="line">Supports Chrome v64<span class="number">-66</span></span><br><span class="line">----------ChromeDriver v2<span class="number">.36</span> (<span class="number">2018</span><span class="number">-03</span><span class="number">-02</span>)----------</span><br><span class="line">Supports Chrome v63<span class="number">-65</span></span><br></pre></td></tr></table></figure><p>那个Supports Chrome v65-67就是对应的Chrome的版本，比如你的Chrome版本是64版本，就一定要使用2.37版本或者2.36版本，不可以使用2.38版本</p><p>下载后，把下载的文件放入到chrome安装路径下即可(Mac需要在应用程序上右键显示包内容下)</p><p>最后运行你的程序即可，就可以不报错了</p><p>最后奉上老司机福利，能不能看懂就看你自己了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"> </span><br><span class="line">xp_href = <span class="string">"//div[@class='item']//a/@href|//div[@class='item ']//a/@href"</span></span><br><span class="line">xp_video_reg = <span class="string">"//video/@src"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderYellow</span><span class="params">(object)</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#创建保存文件夹</span></span><br><span class="line">    self.downloadDir = <span class="string">"./movies"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(self.downloadDir)==<span class="literal">False</span>:</span><br><span class="line">    os.mkdir(self.downloadDir)</span><br><span class="line">    <span class="comment">#保存此次下载的文件信息</span></span><br><span class="line">    self.downloadInfo = &#123;&#125;</span><br><span class="line">    <span class="comment">#想爬取的个数</span></span><br><span class="line">    self.max_count = <span class="number">0</span></span><br><span class="line">    <span class="comment">#发现的连接名称</span></span><br><span class="line">    self.setHref= set([])</span><br><span class="line">    <span class="comment">#下载的队列</span></span><br><span class="line">    self.htmlQueue = []</span><br><span class="line">    <span class="comment">#从连接中获得的视频</span></span><br><span class="line">    self.setUrl = set([])</span><br><span class="line">    <span class="comment">#谷歌chromeDriver设置请求头 ，并打开无界面浏览器加载动态js网页</span></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--disable-gpu'</span>)</span><br><span class="line">    chrome_options.add_argument(</span><br><span class="line">    <span class="string">'User-Agent="Mozilla/5.0 (iPod; U; CPU iPhone OS 2_1 like Mac OS X; ja-jp) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5F137 Safari/525.20"'</span>)</span><br><span class="line">    self.driver = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">    <span class="comment">#设置requests请求头</span></span><br><span class="line">    self.headers = &#123;<span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (iPod; U; CPU iPhone OS 2_1 like Mac OS X; ja-jp) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5F137 Safari/525.20"</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#保存的视频信息</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">save_video</span><span class="params">(self,src)</span>:</span></span><br><span class="line">   print(<span class="string">"saving... ==&gt;"</span>,src)</span><br><span class="line">   self.setUrl.add(src)</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#从第一个界面中获得视频链接地址</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">find_videoInfo</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">while</span> len(self.setUrl) &lt; self.max_count:</span><br><span class="line">       url = self.htmlQueue.pop()</span><br><span class="line">       <span class="keyword">if</span> url:</span><br><span class="line">            print(<span class="string">'analysis:'</span>, url)</span><br><span class="line">            html = self.downloadHtml(url)</span><br><span class="line">            self.analysisHtml(html)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadHtml</span><span class="params">(self,url)</span>:</span></span><br><span class="line">       self.driver.get(url)</span><br><span class="line">       <span class="keyword">return</span> self.driver.page_source</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysisHtml</span><span class="params">(self,html)</span>:</span></span><br><span class="line">     tree = etree.HTML(html)</span><br><span class="line">     <span class="comment"># 查找视频信息</span></span><br><span class="line">     videoInfo = tree.xpath(xp_video_reg)</span><br><span class="line">     <span class="comment"># 保存视频信息</span></span><br><span class="line">     <span class="keyword">for</span> video <span class="keyword">in</span> videoInfo:</span><br><span class="line">        self.save_video(video)</span><br><span class="line">     <span class="comment"># 查找新的非重复本域名标签</span></span><br><span class="line">     hrefInfo = tree.xpath(xp_href)</span><br><span class="line">     <span class="keyword">for</span> href <span class="keyword">in</span> hrefInfo:</span><br><span class="line">         href = urllib.parse.urljoin(self.seedurl, href)</span><br><span class="line">         <span class="keyword">if</span> href <span class="keyword">not</span> <span class="keyword">in</span> self.setHref:</span><br><span class="line">             self.setHref.add(href)</span><br><span class="line">             self.htmlQueue.append(href)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_video_src</span><span class="params">(self,url)</span>:</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_download</span><span class="params">(self,url)</span>:</span></span><br><span class="line">    print(<span class="string">"start write to file"</span>,url)</span><br><span class="line">    r = requests.get(url,headers=self.headers,stream= <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(self.downloadDir,url.split(<span class="string">'/'</span>)[<span class="number">-2</span>]),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">         <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">              f.write(chunk)</span><br><span class="line">    print(<span class="string">"download success"</span>,url)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutiDownload</span><span class="params">(self,urls)</span>:</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        pool.apply_async(self._download(url))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self,seed_url,maxCount)</span>:</span></span><br><span class="line">    self.seedurl = seed_url</span><br><span class="line">    self.max_count = maxCount</span><br><span class="line">    self.htmlQueue.append(seed_url)</span><br><span class="line">    self.find_videoInfo()</span><br><span class="line">    self.mutiDownload(self.setUrl)</span><br><span class="line">s = SpiderYellow()</span><br><span class="line">s.start(<span class="string">"http://dyz44.com/latest-updates/"</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Selenium</category>
      
      <category>爬虫+selenium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>selenium</tag>
      
      <tag>爬虫+selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器网页远程访问桌面</title>
    <link href="undefined2018/11/02/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E9%A1%B5%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%A1%8C%E9%9D%A2/"/>
    <url>2018/11/02/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E9%A1%B5%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%A1%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="docker容器网页远程访问桌面"><a href="#docker容器网页远程访问桌面" class="headerlink" title="docker容器网页远程访问桌面"></a>docker容器网页远程访问桌面</h1><p>前言：</p><p>说在前面，目前市面上的docker images界面都是基于xfce的，我们通常安装的Ubuntu都是Unity的，二者安装完后不一样，会对学生学习造成很大困扰，所以在这里介绍一下如何安装基于Unity的镜像</p><p>一、主要功能:</p><p>通过网页访问docker容器的界面，达到图形化操作</p><p>二、专业名词</p><p>docker:一个管理容器的东西，类似虚拟机的概念，但是比虚拟机更加快捷方便，多用于部署使用</p><p>VNCServer:主要用于启动服务，使用VNCViewer可以直接远程访问</p><p>VNCViewer：客户端程序，用于任意的远程连接VNCServer启动的服务</p><p>noVNC：主要和VNCServer一起，为VNCServer提供网页访问支持</p><p>三、部署</p><p>sudo docker run -itd -p 6080:6080 -e PASSWORD=1 -e SUDO=yes –name zc004 land007/ubuntu-unity-novnc</p><p>启动后访问以下地址即可远程显示，密码是1。这个1即是vnc连接的1，也是root密码</p><p><a href="http://localhost:6080/vnc.html" target="_blank" rel="noopener">http://localhost:6080/vnc.html</a></p><p>四、嵌入到项目</p><!DOCTYPE html><html style="“height:" 100%;“><head><meta name="generator" content="Hexo 3.9.0"><meta charset="“utf-8”"><title></title></head><body style="“height:" 100%;“><iframe src="“http://localhost:6080/vnc.html”" style="“width:" 100%;height: 100%;“></iframe></body></html><p>五、代码动态创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create_container(image=&apos;land007/ubuntu-unity-novnc&apos;, name=&apos;zc009&apos;,                             ports=[6080],                             command = &quot;/home/ubuntu/startup.sh&quot;,                             environment=&#123;&quot;LANG&quot;: &quot;zh_CN.utf8&quot;,&quot;PASSWORD&quot;:&quot;1&quot;,&quot;SUDO&quot;:&quot;yes&quot;&#125;,                             hostname=&apos;zc01&apos;,                             host_config=client.create_host_config(privileged=True, port_bindings=&#123;6080:6080&#125;))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#这个命令在Ubuntu没有 command = &quot;/usr/sbin/init&quot;，但是一定要执行/home/ubuntu/startup.sh，否则容器会挂掉</span><br></pre></td></tr></table></figure><p>五、xfce桌面</p><p>如果不是太在乎桌面的话，可以在hub.docker.com上搜索<a href="https://hub.docker.com/u/consol/" target="_blank" rel="noopener">consol</a>/<a href="https://hub.docker.com/r/consol/ubuntu-xfce-vnc/" target="_blank" rel="noopener">ubuntu-xfce-vnc</a> 这个镜像进行使用，这个系列包含了Ubuntu，centos的版本，比较全面</p><p>docker run -d -p 5901:5901 -p 6901:6901 consol/centos-xfce-vnc</p><p>访问以下地址即可使用</p><p><a href="http://localhost:6901/vnc.html" target="_blank" rel="noopener">http://localhost:6901/vnc.html</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python内置函数整理</title>
    <link href="undefined2018/10/21/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <url>2018/10/21/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>内置函数就是python给你提供的, 拿来直接用的函数，比如print.，input等。<strong>截止到python版本3.6.2 python一共提供了68个内置函数。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#68个内置函数# abs()         　　dict()      　　help()       　　min()       　　setattr()# all()         　　dir()       　　hex()        　　next()      　　slice() # any()         　　divmod()    　　id()         　　object()    　　sorted() # ascii()       　　enumerate() 　　input()      　　oct()       　　staticmethod() # bin()         　　eval()      　　int()        　　open()      　　str() # bool()        　　exec()      　　isinstance() 　　ord()       　　sum() # bytearray()   　　ﬁlter()     　　issubclass() 　　pow()       　　super() # bytes()       　　ﬂoat()      　　iter()       　　print()     　　tuple() # callable()    　　format()    　　len()        　　property()  　　type() # chr()         　　frozenset() 　　list()       　　range()     　　vars() # classmethod() 　　getattr()   　　locals()     　　repr()      　　zip() # compile()     　　globals()   　　map()        　　reversed()  　　__import__() # complex()     　　hasattr()   　　max()        　　round() # delattr()     　　hash()      　　memoryview() 　　set()</span><br></pre></td></tr></table></figure><p><strong>和数字相关</strong></p><p><strong>1. 数据类型</strong></p><ul><li>bool : 布尔型(True,False)</li><li>int : 整型(整数)</li><li>float : 浮点型(小数)</li><li>complex : 复数</li></ul><p><strong>2. 进制转换</strong></p><ul><li>bin() 将给的参数转换成二进制</li><li>otc() 将给的参数转换成八进制</li><li>hex() 将给的参数转换成十六进制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(bin(10))  # 二进制:0b1010print(hex(10))  # 十六进制:0xaprint(oct(10))  # 八进制:0o12</span><br></pre></td></tr></table></figure><p><strong>3. 数学运算</strong></p><ul><li>abs() 返回绝对值</li><li>divmode() 返回商和余数</li><li>round() 四舍五入</li><li>pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余</li><li>sum() 求和</li><li>min() 求最小值</li><li>max() 求最大值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(abs(-2))  # 绝对值:2print(divmod(20,3)) # 求商和余数:(6,2)print(round(4.50))   # 五舍六入:4print(round(4.51))   #5print(pow(10,2,3))  # 如果给了第三个参数. 表示最后取余:1print(sum([1,2,3,4,5,6,7,8,9,10]))  # 求和:55print(min(5,3,9,12,7,2))  #求最小值:2print(max(7,3,15,9,4,13))  #求最大值:15</span><br></pre></td></tr></table></figure><p><strong>和数据结构相关</strong></p><p><strong>1. 序列</strong></p><p>（1）列表和元组</p><ul><li>list() 将一个可迭代对象转换成列表</li><li>tuple() 将一个可迭代对象转换成元组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list((1,2,3,4,5,6)))  #[1, 2, 3, 4, 5, 6]print(tuple([1,2,3,4,5,6]))  #(1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure><p>（2）相关内置函数</p><ul><li>reversed() 将一个序列翻转, 返回翻转序列的迭代器</li><li>slice() 列表的切片</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst = &quot;你好啊&quot;it = reversed(lst)   # 不会改变原列表. 返回一个迭代器, 设计上的一个规则print(list(it))  #[&apos;啊&apos;, &apos;好&apos;, &apos;你&apos;]lst = [1, 2, 3, 4, 5, 6, 7]print(lst[1:3:1])  #[2,3]s = slice(1, 3, 1)  #  切片用的print(lst[s])  #[2,3]</span><br></pre></td></tr></table></figure><p>（3）字符串</p><ul><li>str() 将数据转化成字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(str(123)+&apos;456&apos;)  #123456　　format()     与具体数据相关, 用于计算各种小数, 精算等.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;hello world!&quot;print(format(s, &quot;^20&quot;))  #剧中print(format(s, &quot;&lt;20&quot;))  #左对齐print(format(s, &quot;&gt;20&quot;))  #右对齐#     hello world!    # hello world!        #         hello world!print(format(3, &apos;b&apos; ))    # 二进制:11print(format(97, &apos;c&apos; ))   # 转换成unicode字符:aprint(format(11, &apos;d&apos; ))   # ⼗进制:11print(format(11, &apos;o&apos; ))   # 八进制:13 print(format(11, &apos;x&apos; ))   # 十六进制(⼩写字母):bprint(format(11, &apos;X&apos; ))   # 十六进制(大写字母):Bprint(format(11, &apos;n&apos; ))   # 和d⼀样:11print(format(11))         # 和d⼀样:11print(format(123456789, &apos;e&apos; ))      # 科学计数法. 默认保留6位小数:1.234568e+08print(format(123456789, &apos;0.2e&apos; ))   # 科学计数法. 保留2位小数(小写):1.23e+08print(format(123456789, &apos;0.2E&apos; ))   # 科学计数法. 保留2位小数(大写):1.23E+08print(format(1.23456789, &apos;f&apos; ))     # 小数点计数法. 保留6位小数:1.234568print(format(1.23456789, &apos;0.2f&apos; ))  # 小数点计数法. 保留2位小数:1.23print(format(1.23456789, &apos;0.10f&apos;))  # 小数点计数法. 保留10位小数:1.2345678900print(format(1.23456789e+3, &apos;F&apos;))   # 小数点计数法. 很大的时候输出INF:1234.567890</span><br></pre></td></tr></table></figure><ul><li>bytes() 把字符串转化成bytes类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bs = bytes(&quot;今天吃饭了吗&quot;, encoding=&quot;utf-8&quot;)print(bs)  #b&apos;\xe4\xbb\x8a\xe5\xa4\xa9\xe5\x90\x83\xe9\xa5\xad\xe4\xba\x86\xe5\x90\x97&apos;　　 bytearray()    返回一个新字节数组. 这个数字的元素是可变的, 并且每个元素的值得范围是[0,256)ret = bytearray(&quot;alex&quot; ,encoding =&apos;utf-8&apos;)print(ret[0])  #97print(ret)  #bytearray(b&apos;alex&apos;)ret[0] = 65  #把65的位置A赋值给ret[0]print(str(ret))  #bytearray(b&apos;Alex&apos;)</span><br></pre></td></tr></table></figure><ul><li>ord() 输入字符找带字符编码的位置</li><li>chr() 输入位置数字找出对应的字符</li><li>ascii() 是ascii码中的返回该值 不是就返回u</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(ord(&apos;a&apos;))  # 字母a在编码表中的码位:97print(ord(&apos;中&apos;))  # &apos;中&apos;字在编码表中的位置:20013print(chr(65))  # 已知码位,求字符是什么:Aprint(chr(19999))  #丟for i in range(65536):  #打印出0到65535的字符    print(chr(i), end=&quot; &quot;)print(ascii(&quot;@&quot;))  #&apos;@&apos;</span><br></pre></td></tr></table></figure><ul><li>repr() 返回一个对象的string形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;今天\n吃了%s顿\t饭&quot; % 3print(s)#今天# 吃了3顿    饭print(repr(s))   # 原样输出,过滤掉转义字符 \n \t \r 不管百分号%#&apos;今天\n吃了3顿\t饭&apos;</span><br></pre></td></tr></table></figure><p><strong>2. 数据集合</strong></p><ul><li>字典：dict 创建一个字典</li><li>集合：set 创建一个集合</li></ul><p><strong>frozenset() 创建一个冻结的集合，冻结的集合不能进行添加和删除操作。</strong></p><p><strong>3. 相关内置函数</strong></p><ul><li>len() 返回一个对象中的元素的个数</li><li>sorted() 对可迭代对象进行排序操作 (lamda)</li></ul><p><strong>语法：sorted(Iterable, key=函数(排序规则), reverse=False)</strong></p><ul><li>Iterable: 可迭代对象</li><li>key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序</li><li>reverse: 是否是倒叙. True: 倒叙, False: 正序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst = [5,7,6,12,1,13,9,18,5]lst.sort()  # sort是list里面的一个方法print(lst)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]ll = sorted(lst) # 内置函数. 返回给你一个新列表  新列表是被排序的print(ll)  #[1, 5, 5, 6, 7, 9, 12, 13, 18]l2 = sorted(lst,reverse=True)  #倒序print(l2)  #[18, 13, 12, 9, 7, 6, 5, 5, 1]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#根据字符串长度给列表排序lst = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;five&apos;, &apos;six&apos;]def f(s):    return len(s)l1 = sorted(lst, key=f, )print(l1)  #[&apos;one&apos;, &apos;two&apos;, &apos;six&apos;, &apos;four&apos;, &apos;five&apos;, &apos;three&apos;]</span><br></pre></td></tr></table></figure><ul><li>enumerate() 获取集合的枚举对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;,&apos;five&apos;]for index, el in enumerate(lst,1):    # 把索引和元素一起获取,索引默认从0开始. 可以更改    print(index)    print(el)# 1# one# 2# two# 3# three# 4# four# 5# five</span><br></pre></td></tr></table></figure><ul><li>all() 可迭代对象中全部是True, 结果才是True</li><li>any() 可迭代对象中有一个是True, 结果就是True</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(all([1,&apos;hello&apos;,True,9]))  #Trueprint(any([0,0,0,False,1,&apos;good&apos;]))  #True</span><br></pre></td></tr></table></figure><ul><li>zip() 函数用于将可迭代的对象作为参数, 将对象中对应的元素打包成一个元组, 然后返回由这些元组组成的列表. 如果各个迭代器的元素个数不一致, 则返回列表长度与最短的对象相同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [1, 2, 3, 4, 5, 6]lst2 = [&apos;醉乡民谣&apos;, &apos;驴得水&apos;, &apos;放牛班的春天&apos;, &apos;美丽人生&apos;, &apos;辩护人&apos;, &apos;被嫌弃的松子的一生&apos;]lst3 = [&apos;美国&apos;, &apos;中国&apos;, &apos;法国&apos;, &apos;意大利&apos;, &apos;韩国&apos;, &apos;日本&apos;]print(zip(lst1, lst1, lst3))  #&lt;zip object at 0x00000256CA6C7A88&gt;for el in zip(lst1, lst2, lst3):    print(el)# (1, &apos;醉乡民谣&apos;, &apos;美国&apos;)# (2, &apos;驴得水&apos;, &apos;中国&apos;)# (3, &apos;放牛班的春天&apos;, &apos;法国&apos;)# (4, &apos;美丽人生&apos;, &apos;意大利&apos;)# (5, &apos;辩护人&apos;, &apos;韩国&apos;)# (6, &apos;被嫌弃的松子的一生&apos;, &apos;日本&apos;)</span><br></pre></td></tr></table></figure><ul><li>fiter() 过滤 (lamda)</li></ul><p><strong>语法：fiter(function. Iterable)</strong></p><p>function: 用来筛选的函数. 在ﬁlter中会自动的把iterable中的元素传递给function. 然后根据function返回的True或者False来判断是否保留留此项数据 , Iterable: 可迭代对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def func(i):    # 判断奇数    return i % 2 == 1    lst = [1,2,3,4,5,6,7,8,9]l1 = filter(func, lst)  #l1是迭代器print(l1)  #&lt;filter object at 0x000001CE3CA98AC8&gt;print(list(l1))  #[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><ul><li>map() 会根据提供的函数对指定序列列做映射(lamda)</li></ul><p><strong>语法 : map(function, iterable)</strong></p><p>可以对可迭代对象中的每一个元素进行映射. 分别去执行 function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def f(i):    return ilst = [1,2,3,4,5,6,7,]it = map(f, lst) # 把可迭代对象中的每一个元素传递给前面的函数进行处理. 处理的结果会返回成迭代器print(list(it))  #[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><p><strong>和作用域相关</strong></p><ul><li>locals() 返回当前作用域中的名字</li><li>globals() 返回全局作用域中的名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def func():    a = 10    print(locals())  # 当前作用域中的内容    print(globals())  # 全局作用域中的内容    print(&quot;今天内容很多&quot;)func()# &#123;&apos;a&apos;: 10&#125;# &#123;&apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__package__&apos;: None, &apos;__loader__&apos;: # &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000026F8D566080&gt;, # &apos;__spec__&apos;: None, &apos;__annotations__&apos;: &#123;&#125;, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; # (built-in)&gt;, &apos;__file__&apos;: &apos;D:/pycharm/练习/week03/new14.py&apos;, &apos;__cached__&apos;: None,#  &apos;func&apos;: &lt;function func at 0x0000026F8D6B97B8&gt;&#125;# 今天内容很多</span><br></pre></td></tr></table></figure><p><strong>和迭代器/生成器相关</strong></p><ul><li>range() 生成数据</li><li>next() 迭代器向下执行一次, 内部实际使⽤用了__ next__()⽅方法返回迭代器的下一个项目</li><li>iter() 获取迭代器, 内部实际使用的是__ iter__()⽅方法来获取迭代器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in range(15,-1,-5):    print(i)# 15# 10# 5# 0lst = [1,2,3,4,5]it = iter(lst)  #  __iter__()获得迭代器print(it.__next__())  #1print(next(it)) #2  __next__()  print(next(it))  #3print(next(it))  #4</span><br></pre></td></tr></table></figure><p><strong>字符串类型代码的执行</strong></p><ul><li>eval() 执行字符串类型的代码. 并返回最终结果</li><li>exec() 执行字符串类型的代码</li><li>compile() 将字符串类型的代码编码. 代码对象能够通过exec语句来执行或者eval()进行求值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = input(&quot;请输入a+b:&quot;)  #输入:8+9print(eval(s1))  # 17 可以动态的执行代码. 代码必须有返回值s2 = &quot;for i in range(5): print(i)&quot;a = exec(s2) # exec 执行代码不返回任何内容# 0# 1# 2# 3# 4print(a)  #None# 动态执行代码exec(&quot;&quot;&quot;def func():    print(&quot; 我是周杰伦&quot;)&quot;&quot;&quot; )func()  #我是周杰伦</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code1 = &quot;for i in range(3): print(i)&quot;com = compile(code1, &quot;&quot;, mode=&quot;exec&quot;)   # compile并不会执行你的代码.只是编译exec(com)   # 执行编译的结果# 0# 1# 2code2 = &quot;5+6+7&quot;com2 = compile(code2, &quot;&quot;, mode=&quot;eval&quot;)print(eval(com2))  # 18code3 = &quot;name = input(&apos;请输入你的名字:&apos;)&quot;  #输入:hellocom3 = compile(code3, &quot;&quot;, mode=&quot;single&quot;)exec(com3)print(name)  #hello</span><br></pre></td></tr></table></figure><p><strong>输入输出</strong></p><ul><li>print() : 打印输出</li><li>input() : 获取用户输出的内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello&quot;, &quot;world&quot;, sep=&quot;*&quot;, end=&quot;@&quot;) # sep:打印出的内容用什么连接,end:以什么为结尾#hello*world@</span><br></pre></td></tr></table></figure><p><strong>内存相关</strong></p><p>hash() : 获取到对象的哈希值(int, str, bool, tuple). hash算法:(1) 目的是唯一性 (2) dict 查找效率非常高, hash表.用空间换的时间 比较耗费内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;alex&apos;print(hash(s))  #-168324845050430382lst = [1, 2, 3, 4, 5]print(hash(lst))  #报错,列表是不可哈希的　　id() :  获取到对象的内存地址s = &apos;alex&apos;print(id(s))  #2278345368944</span><br></pre></td></tr></table></figure><p><strong>文件操作相关</strong></p><ul><li>open() : 用于打开一个文件, 创建一个文件句柄</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;file&apos;,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;)f.read()f.close()</span><br></pre></td></tr></table></figure><p><strong>模块相关</strong></p><ul><li>__ import__() : 用于动态加载类和函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 让用户输入一个要导入的模块import osname = input(&quot;请输入你要导入的模块:&quot;)__import__(name)    # 可以动态导入模块</span><br></pre></td></tr></table></figure><p><strong>帮 助</strong></p><ul><li>help() : 函数用于查看函数或模块用途的详细说明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(help(str))  #查看字符串的用途</span><br></pre></td></tr></table></figure><p><strong>调用相关</strong></p><ul><li>callable() : 用于检查一个对象是否是可调用的. 如果返回True, object有可能调用失败, 但如果返回False. 那调用绝对不会成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10print(callable(a))  #False  变量a不能被调用#def f():    print(&quot;hello&quot;)    print(callable(f))   # True 函数是可以被调用的</span><br></pre></td></tr></table></figure><p><strong>查看内置属性</strong></p><ul><li>dir() : 查看对象的内置属性, 访问的是对象中的<strong>dir</strong>()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(tuple))  #查看元组的方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql_win</title>
    <link href="undefined2018/08/25/mysql-win/"/>
    <url>2018/08/25/mysql-win/</url>
    
    <content type="html"><![CDATA[<p>严格意义上来说mysql8和win10都是大坑，里面有着无数不一样的地方</p><p>1：首先去官网下载安装包</p><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>选择对应5.7.24版本的</p><p>2：将解压文件解压到你安装的目录：E:\mysql-5.7.24-winx64  （我这是放在E盘根目录，不要放在有中文名字和空格的的目录下.例如</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/12/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-12-25-%E4%B8%8B%E5%8D%888.37.00-1.png" srcset="/img/loading.gif" alt="img"></p><p>3：在mysql-5.7.24-winx64文件夹下面新建一个my.ini文件和一个data文件夹，(注意my.ini后缀名是ini,别弄个my.ini.txt我也为你准备了这个文件，记得下载下来以后解压缩) 注意我这里里面写的路径和版本号你需要修改下</p><p><a href="http://47.93.248.15/wp-content/uploads/2018/12/my.ini_.zip" target="_blank" rel="noopener">my.ini</a></p><p>不想下载，可以创建my.ini,复制以下内容</p><p>my.ini内容：</p><p>5：以管理员的身份打开cmd窗口跳转路径到E:\mysql-8.0.11-winx64\bin</p><p>初始化命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld --initialize --user=mysql --console</span><br></pre></td></tr></table></figure><p>(记住一定要进行初始化，很多人不进行初始化，就出现了1067错误，怎么弄都搞不定)</p><p>初始化完成之后，会生成一个临时密码这里需要注意把临时密码记住（在）</p><p>然后在你的数据库保存目录生成一些文件，不用管</p><p>这里需要注意使用./mysqld   因为你直接使用mysqld，有可能会找不到</p><p>接着就是输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure><p>进行服务的添加</p><p>输入net start mysql启动服务</p><p>输入mysql -u root -p进行登录数据库，这时提示需要密码，然后就是用你上面的密码登录</p><p>修改密码语句：ALTER USER root@localhost IDENTIFIED  BY ‘123456’;    修改密码为：123456</p><p>—————————————————————————————–</p><p>接下来大坑就来了</p><p>在连接Navicat时候，会出现1251的错误，这个是因为mysql8 之前的版本中加密规则是mysql_native_password,而在mysql7之后,加密规则是caching_sha2_password, 解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password.</p><p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘123456’ PASSWORD EXPIRE NEVER; #修改加密规则<br>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’; #更新一下用户的密码<br>FLUSH PRIVILEGES; #刷新权限</p><p>—————————————————————————————–</p><p>我看好多人拿着命令直接复制，这样是不对的。</p><p>‘root’   为你自己定义的用户名</p><p>‘localhost’ 指的是用户开放的IP，可以是’localhost’(仅本机访问，相当于127.0.0.1)，可以是具体的’<em>.</em>.<em>.</em>‘(具体某一IP)，也可以是 ‘%’ (所有IP均可访问)</p><p>‘password’ 是你想使用的用户密码</p><p>—————————————————————————————–</p><p>问题就解决了</p>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu MongoDB数据库的安装和使用</title>
    <link href="undefined2018/08/12/Ubuntu-MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>2018/08/12/Ubuntu-MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本博文介绍了MongoDB，并详细指引读者在Ubuntu下MongoDB的安装和使用。本教程在Ubuntu14.04下测试通过。 </p><h2 id="一、MongoDB介绍"><a href="#一、MongoDB介绍" class="headerlink" title="一、MongoDB介绍"></a>一、MongoDB介绍</h2><p>MongoDB 是一个是一个基于分布式文件存储的数据库，介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><a id="more"></a><h2 id="二、安装MongoDB"><a href="#二、安装MongoDB" class="headerlink" title="二、安装MongoDB"></a>二、安装MongoDB</h2><p>MongoDB安装很简单，无需下载源文件，可以直接用apt-get命令进行安装。<br>打开终端，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mongodb</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9135759-3cb41a51c148257b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>1.安装完成后，在终端输入以下命令查看MongoDB版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo -version</span><br></pre></td></tr></table></figure><p>输出版本信息，表明安装成功，截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-8887c3331cd9528f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>2.启动和关闭mongodb命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service mongodb start</span><br><span class="line">service mongodb stop</span><br></pre></td></tr></table></figure><p>截图如下：<br> <img src="https://upload-images.jianshu.io/upload_images/9135759-39cb7f47b78e2337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>3.默认设置MongoDB是随Ubuntu启动自动启动的。<br>输入以下命令查看是否启动成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep mongo -l   #注意：-l是英文字母l，不是阿拉伯数字1</span><br></pre></td></tr></table></figure><p>截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-f7a5306aeaed8158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>卸载MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove mongodb mongodb-clients mongodb-server</span><br></pre></td></tr></table></figure><h2 id="三、使用MongoDB"><a href="#三、使用MongoDB" class="headerlink" title="三、使用MongoDB"></a>三、使用MongoDB</h2><h3 id="shell命令模式"><a href="#shell命令模式" class="headerlink" title="shell命令模式"></a>shell命令模式</h3><p>输入<code>mongo</code>进入shell命令模式，默认连接的数据库是test数据库，在此之前一定要确保你已经启动了MongoDB，否则会出现错误，启动之后运行成功，如下截图：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-47a98bbf23b2cfc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>常用操作命令：<br>数据库相关 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show dbs:显示数据库列表 </span><br><span class="line">show collections：显示当前数据库中的集合（类似关系数据库中的表table） </span><br><span class="line">show users：显示所有用户 </span><br><span class="line">use yourDB：切换当前数据库至yourDB </span><br><span class="line">db.help() ：显示数据库操作命令 </span><br><span class="line">db.yourCollection.help() ：显示集合操作命令，yourCollection是集合名</span><br></pre></td></tr></table></figure><p>MongoDB没有创建数据库的命令，如果你想创建一个“School”的数据库，先运行use School命令，之后做一些操作（如：创建聚集集合db.createCollection(‘teacher’)）,这样就可以创建一个名叫“School”的数据库。<br>截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-378e2b1d94454111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><h3 id="下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。"><a href="#下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。" class="headerlink" title="下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。"></a>下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。</h3><p>1、切换到School数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use School #切换到School数据库。MongoDB 无需预创建School数据库，在使用时会自动创建</span><br></pre></td></tr></table></figure><p>2、创建Collection</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;teacher&apos;) #创建一个聚集集合。MongoDB 其实在插入数据的时候，也会自动创建对应的集合，无需预定义集合</span><br></pre></td></tr></table></figure><p>截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-81643b44864ee245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>3、插入数据<br>与数据库创建类似，插入数据时也会自动创建集合。<br>插入数据有两种方式：insert和save。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.student.insert(&#123;_id:1, sname: &apos;zhangsan&apos;, sage: 20&#125;) #_id可选</span><br><span class="line">db.student.save(&#123;_id:1, sname: &apos;zhangsan&apos;, sage: 22&#125;) #_id可选</span><br></pre></td></tr></table></figure><p>这两种方式，其插入的数据中_id字段均可不写，会自动生成一个唯一的_id来标识本条数据。而insert和save不同之处在于：在手动插入_id字段时，如果_id已经存在，insert不做操作，save做更新操作；如果不加_id字段，两者作用相同都是插入数据。<br>截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-f266803fccc124ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>添加的数据其结构是松散的，只要是bson格式均可，列属性均不固定，根据添加的数据为准。先定义数据再插入，就可以一次性插入多条数据，截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-6a2feadc2cbe01c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>运行完以上例子，student 已自动创建，这也说明 MongoDB 不需要预先定义 collection ，在第一次插入数据后，collection 会自动的创建。<br>截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-d56b0ffb7ecc980a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>4、查找数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.youCollection.find(criteria, filterDisplay)</span><br></pre></td></tr></table></figure><p>criteria ：查询条件，可选<br>filterDisplay：筛选显示部分数据，如显示指定列数据，可选（当选择时，第一个参数不可省略，若查询条件为空，可用{}做占位符，如下例第三句）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.find()  #查询所有记录。相当于：select * from student</span><br><span class="line">db.student.find(&#123;sname: &apos;lisi&apos;&#125;)  #查询sname=&apos;lisi&apos;的记录。相当于： select * from student where sname=&apos;lisi&apos;</span><br><span class="line">db.student.find(&#123;&#125;,&#123;sname:1, sage:1&#125;) #查询指定列sname、sage数据。相当于：select sname,sage from student。sname:1表示返回sname列，默认_id字段也是返回的，可以添加_id:0（意为不返回_id）写成&#123;sname: 1, sage: 1,_id:0&#125;，就不会返回默认的_id字段了</span><br><span class="line">db.student.find(&#123;sname: &apos;zhangsan&apos;, sage: 22&#125;) #and 与条件查询。相当于：select * from student where sname = &apos;zhangsan&apos; and sage = 22</span><br><span class="line">db.student.find(&#123;$or: [&#123;sage: 22&#125;, &#123;sage: 25&#125;]&#125;) #or 条件查询。相当于：select * from student where sage = 22 or sage = 25</span><br></pre></td></tr></table></figure><p>查询操作类似，这里只给出db.student.find({sname: ‘lisi’})<br>查询的截图，如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-75add83f6cda14bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>5、修改数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.youCollection.update(criteria, objNew, upsert, multi ) </span><br><span class="line">criteria: update的查询条件，类似sql update查询内where后面的 </span><br><span class="line">objNew : update的对象和一些更新的操作符（如$set）等，也可以理解为sql update查询内set后面的。 </span><br><span class="line">upsert : 如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。 </span><br><span class="line">multi: mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。默认false，只修改匹配到的第一条数据。 </span><br><span class="line">其中criteria和objNew是必选参数，upsert和multi可选参数</span><br></pre></td></tr></table></figure><p>举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;sname: &apos;lisi&apos;&#125;, &#123;$set: &#123;sage: 30&#125;&#125;, false, true) #相当于：update student set sage =30 where sname = &apos;lisi&apos;;</span><br></pre></td></tr></table></figure><p>操作截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-9a33162889a67bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>6、删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.remove(&#123;sname: &apos;chenliu&apos;&#125;) #相当于：delete from student where sname=&apos;chenliu&apos;</span><br></pre></td></tr></table></figure><p>操作截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/9135759-bb17d02c7a2f0f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>7、退出shell命令模式<br>输入exit或者Ctrl+C退出shell命令模式</p><hr><p>参考MongoDB官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/?_ga=2.38644067.1704633038.1522762185-1747967431.1522762185</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>MongoDB数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel-openpyxl-3-增删改查</title>
    <link href="undefined2017/09/30/Excel-openpyxl-3-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>2017/09/30/Excel-openpyxl-3-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Excel-openpyxl-3-增删改查"><a href="#Excel-openpyxl-3-增删改查" class="headerlink" title="Excel-openpyxl-3-增删改查"></a>Excel-openpyxl-3-增删改查</h1><p>通过这篇文章，你能学习到以下内容<br>1、openpyxl的增加数据<br>2、openpyxl删除数据<br>3、更新数据<br>4、查找数据</p><p>1、openpyxl的增加数据</p><p>使用上一个文件创建的create_excel.xlsx</p><p><a href="http://47.93.248.15/wp-content/uploads/2018/05/create_excel.xlsx" target="_blank" rel="noopener">create_excel </a>     原始文件，数据源</p><p><a href="http://47.93.248.15/wp-content/uploads/2018/05/openpyxledit.py_.zip" target="_blank" rel="noopener">openpyxledit.py</a>   相关代码</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-09-%E4%B8%8B%E5%8D%883.25.27.png" srcset="/img/loading.gif" alt="img"></p><p>每次调用，在最后一列，多增加一列数据</p><p>引用模块openpyxl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import load_workbookfrom openpyxl import Workbook# 一个eggache的数字转为列字母的方法from openpyxl.utils import get_column_letter</span><br></pre></td></tr></table></figure><p>目标:调用一次，最后一列增加一列</p><p>思路:</p><p>获得最后一列或者一行的位置</p><p>增加一列:通过cell指定最后一列的位置增加1，依次对这一列的每一行赋值</p><p>增加一行:通过cell指定最后一行位置增加1，依次对这行的每一列进行赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#增加数据def addExcel():    # 打开一个工作薄    wb = load_workbook(&apos;create_excel.xlsx&apos;, data_only=True)  # data_only=True是关键，显示公式结果    # 获取一张表，需要对应那个表的name，之前取的是create_sheet    sheet = wb.get_sheet_by_name(&quot;create_sheet&quot;)    #获得最大行数    row=sheet.max_row    #获得最大列数    column=sheet.max_column    #循环插入一列数据    for i in range(row):        #列数+1转换为字母        h_col = get_column_letter(column+1)        #行数从1开始,从0会报错        xx=h_col+str(i+1)        #可以使用sheet[xx].value=xx方式进行赋值        # sheet[xx].value=xx        #row是数字，column是数字，都是从1开始        sheet.cell(row=(i+1),column=column+1).value=xx    wb.save(&quot;create_excel.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addExcel()</span><br></pre></td></tr></table></figure><p>2、 openpyxl删除数据</p><p>目标:调用一次，最后一行删除一行</p><p>思路：</p><p>openpyxl本身不提供删除，原因在于删除涉及移动数据，但是如果行或者列的数据本身都为None时候，默认这行就是没有的，利用这个规则，可以把一行或者一列的数据全部设置为None即可删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def deleteExcel():    # 打开一个工作薄    wb = load_workbook(&apos;create_excel.xlsx&apos;, data_only=True)  # data_only=True是关键，显示公式结果    # 获取一张表，需要对应那个表的name，之前取的是create_sheet    sheet = wb.get_sheet_by_name(&quot;create_sheet&quot;)    # 获得最大行数    row = sheet.max_row    # 获得最大列数    column = sheet.max_column    print(column)    # 删除最后一列数据    #for i in range(row):    #    sheet.cell(row=(i+1), column=column).value = None    # 删除最后一行数据    for i in range(column):        sheet.cell(row=row,column=i+1).value=None    wb.save(&quot;create_excel.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>调用删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteExcel()</span><br></pre></td></tr></table></figure><p>3、  更新数据</p><p>目标:修改任意数据，进行保存</p><p>思路</p><p>基本思路和增加是一样的，但是比较简单的是不获取一列数据，而是单独的一个cell</p><p>对单独cell赋值后进行保存，即可完成更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def updateExcel():    # 打开一个工作薄    wb = load_workbook(&apos;create_excel.xlsx&apos;, data_only=True)  # data_only=True是关键，显示公式结果    # 获取一张表，需要对应那个表的name，之前取的是create_sheet    sheet = wb.get_sheet_by_name(&quot;create_sheet&quot;)    sheet[&apos;C3&apos;] = &apos;new data&apos;    wb.save(&quot;create_excel.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>调用更新数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateExcel()</span><br></pre></td></tr></table></figure><p>4、 查找数据</p><p>目标:查找所有数据</p><p>思路</p><p>获得最大列和最大行，进行遍历，需要注意行和列都是从1开始的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def selectExcel():    # 打开一个工作薄    wb = load_workbook(&apos;create_excel.xlsx&apos;,data_only=True) #data_only=True是关键，显示公式结果    # 获取一张表，需要对应那个表的name，之前取的是create_sheet    sheet=wb.get_sheet_by_name(&quot;create_sheet&quot;)    # 获取A1格的值    print(&quot;A1的值  &quot;,sheet[&apos;A1&apos;].value)    # 获取表的内容的最大工作行数    print(&quot;表最大工作行数  &quot;,sheet.max_row)    # 获取表的内容的最大工作列数    print(&quot;表最大工作列数  &quot;,sheet.max_column)    # 遍历表中所有内容    for row in sheet.rows:        #row是每一行中的数据        for cell in row:            print(cell.value,end=&quot; &quot;)        print(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>调用查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectExcel()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Excel</category>
      
      <category>Excel-openpyxl-增删改查</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel-openpyxl--数据梳理</title>
    <link href="undefined2017/09/26/Excel-openpyxl-%E6%95%B0%E6%8D%AE%E6%A2%B3%E7%90%86/"/>
    <url>2017/09/26/Excel-openpyxl-%E6%95%B0%E6%8D%AE%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>通过这篇文章，你能学习到以下内容</p><p>1、读取文件<br>2、整理数据结构:字典类型 key是班级id value 是数组类型，数组里面对应的是字典，对应每一行数据<br>3、遍历所有value，读取的数组传入到一个函数中<br>4、函数中处理计数变量，开始遍历数组<br>5、在函数中操作全局变量，记录整理好的数据<br>6、把整理好的数据写入</p><p>1、需求：</p><p>读取<a href="http://47.93.248.15/wp-content/uploads/2018/05/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE.xlsx" target="_blank" rel="noopener">基础数据</a>然后按照<a href="http://47.93.248.15/wp-content/uploads/2018/05/%E7%BB%93%E6%9E%9C%E6%A8%A1%E6%9D%BF.xlsx" target="_blank" rel="noopener">结果模板</a>进行处理，数据中是按照班级进行分组统计</p><p>基础数据一次运算消耗时间太大，简化数据，使用<a href="http://47.93.248.15/wp-content/uploads/2018/05/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE1.xlsx" target="_blank" rel="noopener">基础数据1</a>来调试程序</p><p>2、思路：</p><p>2.1、读取文件<br>2.2、整理数据结构:字典类型 key是班级id value 是数组类型，数组里面对应的是字典，对应每一行数据<br>2.3、遍历所有value，读取的数组传入到一个函数中<br>2.4、函数中处理计数变量，开始遍历数组<br>2.5、在函数中操作全局变量，记录整理好的数据<br>2.6、把整理好的数据写入</p><p>3、实现</p><p><a href="http://47.93.248.15/wp-content/uploads/2018/05/MyTools.py_.zip" target="_blank" rel="noopener">完整代码</a></p><p><strong>读取Excel数据，梳理数据，把id相同的保存在一起，以每行数据作为一个对象，统一操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="comment"># 一个eggache的数字转为列字母的方法</span></span><br><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> get_column_letter</span><br><span class="line"><span class="keyword">from</span> openpyxl.reader.excel <span class="keyword">import</span> load_workbook</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取Excel数据</span></span><br><span class="line"> </span><br><span class="line">dicdata=&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readExcel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    wb2=load_workbook(file_name,data_only=<span class="literal">True</span>)    <span class="comment">#读取excel  data_only=True是关键，显示公式结果</span></span><br><span class="line">    ws2=wb2.get_sheet_by_name(<span class="string">"收入确认"</span>)<span class="comment">#wb2.active是默认第一个</span></span><br><span class="line">    <span class="comment"># ws2=wb2.active#wb2.active是默认第一个</span></span><br><span class="line">    <span class="comment">#读取每一行内容</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="comment">#注 ：ws2.rows[i] 这种方式特别耗时</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> ws2.rows:</span><br><span class="line">        i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        classid=str(row[<span class="number">2</span>].value)</span><br><span class="line">        arr = dicdata.get(classid)</span><br><span class="line">        <span class="keyword">if</span> arr == <span class="literal">None</span>:</span><br><span class="line">            dicdata[classid] = [row]<span class="comment">#如果空就新增一个id对应</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr.append(row)<span class="comment"># 追加数据即可</span></span><br></pre></td></tr></table></figure><p><strong>数据处理，对每一个班级内数据进行合并计算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取Excel数据</span></span><br><span class="line"> </span><br><span class="line">dicdata=&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readExcel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    wb2=load_workbook(file_name,data_only=<span class="literal">True</span>)    <span class="comment">#读取excel  data_only=True是关键，显示公式结果</span></span><br><span class="line">    ws2=wb2.get_sheet_by_name(<span class="string">"收入确认"</span>)<span class="comment">#wb2.active是默认第一个</span></span><br><span class="line">    <span class="comment"># ws2=wb2.active#wb2.active是默认第一个</span></span><br><span class="line">    <span class="comment">#读取每一行内容</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="comment">#注 ：ws2.rows[i] 这种方式特别耗时</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> ws2.rows:</span><br><span class="line">        i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        classid=str(row[<span class="number">2</span>].value)</span><br><span class="line">        arr = dicdata.get(classid)</span><br><span class="line">        <span class="keyword">if</span> arr == <span class="literal">None</span>:</span><br><span class="line">            dicdata[classid] = [row]<span class="comment">#如果空就新增一个id对应</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr.append(row)<span class="comment"># 追加数据即可</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数据处理，对每一个班级内数据进行合并计算</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(arr,classid)</span>:</span></span><br><span class="line">    校区=arr[<span class="number">0</span>][<span class="number">1</span>].value</span><br><span class="line">    班级id=classid</span><br><span class="line">    <span class="comment">#班级名字没有，用班级类型替代</span></span><br><span class="line">    班级名字=arr[<span class="number">0</span>][<span class="number">9</span>].value</span><br><span class="line">    班级类型=arr[<span class="number">0</span>][<span class="number">9</span>].value</span><br><span class="line">    学科=arr[<span class="number">0</span>][<span class="number">10</span>].value</span><br><span class="line">    授课模式=arr[<span class="number">0</span>][<span class="number">17</span>].value</span><br><span class="line">    开班日期=arr[<span class="number">0</span>][<span class="number">13</span>].value</span><br><span class="line">    预计毕业时间=arr[<span class="number">0</span>][<span class="number">14</span>].value</span><br><span class="line">    毕业时间=arr[<span class="number">0</span>][<span class="number">15</span>].value</span><br><span class="line">    预计毕业总时间=arr[<span class="number">0</span>][<span class="number">18</span>].value</span><br><span class="line">    执行价格合计 = 优惠金额小计 = 应交学费合计 =<span class="number">0</span></span><br><span class="line">    新生 = 升级 = 转班来 = 退学归来 = 重读 = 留级 = 退学 = 转班走 = 休学 = 开除 = <span class="number">0</span></span><br><span class="line">    收款合计 = 收款合计<span class="number">2015</span> = 收款合计<span class="number">2016</span> = 收款合计<span class="number">2017</span> = 收款合计<span class="number">2018</span> = <span class="number">0</span></span><br><span class="line">    班级已确认收入小计 = 收入确认培训<span class="number">2015</span> = 收入确认培训<span class="number">2016</span> = 收入确认培训<span class="number">2017</span> = 收入确认培训<span class="number">2018</span> = <span class="number">0</span></span><br><span class="line">    现金折扣合计 = 现金折扣<span class="number">2015</span> = 现金折扣<span class="number">2016</span> = 现金折扣<span class="number">2017</span> = 现金折扣<span class="number">2018</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">#记录后面44-298的所有内容</span></span><br><span class="line">    arrtest=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">38</span>,len(arr[<span class="number">0</span>]))]</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#遍历所有row</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> arr:</span><br><span class="line">        执行价格合计=执行价格合计+row[<span class="number">3</span>].value</span><br><span class="line">        优惠金额小计=优惠金额小计+row[<span class="number">7</span>].value</span><br><span class="line">        应交学费合计=应交学费合计+row[<span class="number">8</span>].value</span><br><span class="line">        <span class="comment">#判断状态</span></span><br><span class="line">        status=row[<span class="number">11</span>].value</span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"新生"</span>:</span><br><span class="line">            新生=新生+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"升级"</span>:</span><br><span class="line">            升级=升级+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"转班来"</span>:</span><br><span class="line">            转班来=转班来+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"退学归来"</span>:</span><br><span class="line">            退学归来=退学归来+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"重读"</span>:</span><br><span class="line">            重读=重读+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"留级"</span>:</span><br><span class="line">            留级=留级+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"退学"</span>:</span><br><span class="line">            退学=退学+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"转班走"</span>:</span><br><span class="line">            转班走=转班走+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"休学"</span>:</span><br><span class="line">            休学=休学+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="string">"开除"</span>:</span><br><span class="line">            开除=开除+<span class="number">1</span></span><br><span class="line">        收款合计=收款合计+row[<span class="number">20</span>].value</span><br><span class="line">        收款合计<span class="number">2015</span>=收款合计<span class="number">2015</span>+row[<span class="number">22</span>].value</span><br><span class="line">        收款合计<span class="number">2016</span>=收款合计<span class="number">2016</span>+row[<span class="number">23</span>].value</span><br><span class="line">        收款合计<span class="number">2017</span>=收款合计<span class="number">2017</span>+row[<span class="number">24</span>].value</span><br><span class="line">        收款合计<span class="number">2018</span> = 收款合计<span class="number">2018</span> + row[<span class="number">25</span>].value</span><br><span class="line">        班级已确认收入小计=班级已确认收入小计+row[<span class="number">26</span>].value</span><br><span class="line">        收入确认培训<span class="number">2015</span>=收入确认培训<span class="number">2015</span>+row[<span class="number">28</span>].value</span><br><span class="line">        收入确认培训<span class="number">2016</span>=收入确认培训<span class="number">2016</span>+row[<span class="number">29</span>].value</span><br><span class="line">        收入确认培训<span class="number">2017</span>=收入确认培训<span class="number">2017</span>+row[<span class="number">30</span>].value</span><br><span class="line">        收入确认培训<span class="number">2018</span>=收入确认培训<span class="number">2018</span>+row[<span class="number">31</span>].value</span><br><span class="line">        现金折扣合计=现金折扣合计+row[<span class="number">32</span>].value</span><br><span class="line">        现金折扣<span class="number">2015</span>=现金折扣<span class="number">2015</span>+row[<span class="number">34</span>].value</span><br><span class="line">        现金折扣<span class="number">2016</span> = 现金折扣<span class="number">2016</span> + row[<span class="number">35</span>].value</span><br><span class="line">        现金折扣<span class="number">2017</span> = 现金折扣<span class="number">2017</span> + row[<span class="number">36</span>].value</span><br><span class="line">        现金折扣<span class="number">2018</span> = 现金折扣<span class="number">2018</span> + row[<span class="number">37</span>].value</span><br><span class="line">        <span class="comment"># 执行价格合计 = 优惠金额小计 = 应交学费合计 0</span></span><br><span class="line">        <span class="comment"># 新生 = 升级 = 转班来 = 退学归来 = 重读 = 留级 = 退学 = 转班走 = 休学 = 开除 = 0</span></span><br><span class="line">        <span class="comment"># 收款合计 = 收款合计2015 = 收款合计2016 = 收款合计2017 = 收款合计2018 = 0</span></span><br><span class="line">        <span class="comment"># 班级已确认收入小计 = 收入确认培训2015 = 收入确认培训2016 = 收入确认培训2017 = 收入确认培训2018 = 0</span></span><br><span class="line">        <span class="comment"># 现金折扣合计 = 现金折扣2015 = 现金折扣2016 = 现金折扣2017 = 现金折扣2018 = 0</span></span><br><span class="line">       <span class="comment">#开始循环剩下的字段</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">38</span>,len(row)):</span><br><span class="line">            <span class="keyword">if</span> row[i].value == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            value=arrtest[i<span class="number">-38</span>];<span class="comment">#读取</span></span><br><span class="line">            value=value+row[i].value<span class="comment">#累加</span></span><br><span class="line">            arrtest[i<span class="number">-38</span>]=value</span><br><span class="line">    <span class="comment"># 保存前面所有累加数据</span></span><br><span class="line">    result_arr = [校区, 班级id, 班级名字, 班级类型, 学科, 授课模式, 开班日期, 预计毕业时间, 毕业时间, 预计毕业总时间, 执行价格合计, 优惠金额小计, 应交学费合计,</span><br><span class="line">                  新生, 升级, 转班来, 退学归来, 重读, 留级, 退学, 转班走, 休学, 开除, 收款合计, 收款合计<span class="number">2015</span>, 收款合计<span class="number">2016</span>, 收款合计<span class="number">2017</span>, 收款合计<span class="number">2018</span>,</span><br><span class="line">                  班级已确认收入小计, 收入确认培训<span class="number">2015</span>, 收入确认培训<span class="number">2016</span>, 收入确认培训<span class="number">2017</span>, 收入确认培训<span class="number">2018</span>, 现金折扣合计, 现金折扣<span class="number">2015</span>, 现金折扣<span class="number">2016</span>, 现金折扣<span class="number">2017</span>,</span><br><span class="line">                  现金折扣<span class="number">2018</span>]</span><br><span class="line">    <span class="comment">#获得的最终每条的总数据</span></span><br><span class="line">    result_arr=result_arr+arrtest</span><br><span class="line">    <span class="keyword">return</span> result_arr</span><br></pre></td></tr></table></figure><p><strong>写入数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_excel_with_openpyxl</span><span class="params">(result_arr,head_row=None,save_excel_name=<span class="string">"save.xlsx"</span>)</span>:</span></span><br><span class="line">    page = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 新建一个workbook</span></span><br><span class="line">    wb = Workbook()</span><br><span class="line">    <span class="comment"># 设置文件输出路径与名称</span></span><br><span class="line">    dest_filename = save_excel_name</span><br><span class="line">    <span class="comment"># 第一个sheet是ws</span></span><br><span class="line">    ws = wb.create_sheet(<span class="number">0</span>,page)</span><br><span class="line">    <span class="comment"># # 写第一行，标题行</span></span><br><span class="line">    <span class="comment"># for h_x in range(1, len(head_row) + 1):</span></span><br><span class="line">    <span class="comment">#     h_col = get_column_letter(h_x)</span></span><br><span class="line">    <span class="comment">#     # print h_col</span></span><br><span class="line">    <span class="comment">#     ws.cell('%s%s' % (h_col, 1)).value = '%s' % (head_row[h_x - 1])</span></span><br><span class="line">    page += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> len(result_arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result_arr)):</span><br><span class="line">        <span class="comment"># 对result的每个子元素作遍历，</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(result_arr[i])):</span><br><span class="line">            <span class="comment">#列是从1开始计算的</span></span><br><span class="line">            ws.cell(row=i+<span class="number">1</span>,column=j+<span class="number">1</span>).value = result_arr[i][j]</span><br><span class="line">    print(<span class="string">"正在写入，进行保存"</span>,dest_filename)</span><br><span class="line">    wb.save(<span class="string">'save.xlsx'</span>)</span><br><span class="line">    <span class="comment"># wb.save(filename=(os.path.dirname(sys.argv[0])+'/save.xlsx'))</span></span><br></pre></td></tr></table></figure><p>最后进行遍历调用每一个数据，保存在数组中进行写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># print(sys.argv[0])#当前文件路径</span></span><br><span class="line">path =os.path.dirname(sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> (path)<span class="comment">#上一级目录</span></span><br><span class="line"> </span><br><span class="line">readExcel(<span class="string">'基础数据1.xlsx'</span>)<span class="comment">#读取了数据</span></span><br><span class="line">allresult_arr=[]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dicdata:</span><br><span class="line">    result_arr= handle_data(dicdata[key],key)</span><br><span class="line">    allresult_arr.append(result_arr)</span><br><span class="line">print(<span class="string">"准备开始写入数据"</span>)</span><br><span class="line">write_to_excel_with_openpyxl(allresult_arr)</span><br><span class="line">print(<span class="string">"写入完成"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Excel</category>
      
      <category>Excel-openpyxl--数据梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel-openpyxl-创建和读取</title>
    <link href="undefined2017/08/05/Excel-openpyxl-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%8F%96/"/>
    <url>2017/08/05/Excel-openpyxl-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>####Excel-openpyxl-创建和读取</p><p>通过这篇文章你能够学习到以下内容**</p><ol><li>操作excel有哪些库</li><li>openpyxl是什么</li><li>openpyxl读取、创建excel</li></ol><p><strong>1、操作**</strong>excel<strong>**有哪些库</strong></p><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-10-%E4%B8%8B%E5%8D%886.11.49-1024x870.png" srcset="/img/loading.gif" alt="img"></p><p>wlrd：只能处理65535行内的数据，如果数据量超过65535行，则会出现报错</p><p><strong>2、openpyxl是什么</strong></p><p>openpyxl模块是一个对Excel操作Python库，能够处理更多数据的内容，但是相对与xlrd，openpyxl的读取效率要远远低于xlrd</p><p>以上需要根据实际业务需求进行选择，这里主要讲解openpyxl库</p><p>首先先清楚一些excel的基本概念：</p><p>在openpyxl中，主要用到三个概念：Workbooks，Sheets，Cells。Workbook就是一个excel工作表；Sheet是工作表中的一张表页；Cell就是简单的一个格。openpyxl就是围绕着这三个概念进行的，不管读写都是“三板斧”：打开Workbook，定位Sheet，操作Cell。</p><p>总结:</p><ul><li>workbooks是excel一个工作表，一个工作表包含多个页，即包含多个sheet</li><li>sheet是excel当中的一页，一个工作页包含多个表格，即包含多个cell</li><li>cell是excel当中的一个工作表格</li></ul><p><strong>3、openpyxl读取、创建excel</strong></p><p><a href="http://47.93.248.15/wp-content/uploads/2018/05/openpyxldemo.py_.zip" target="_blank" rel="noopener">openpyxl读写、创建代码下载</a></p><p>3.1  安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><p>(简便安装:使用pycharm，导入模块，按alt+回车自动安装，其实后面实现也是pip install openpyxl)</p><p>3.2 创建Excel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import load_workbookfrom openpyxl import Workbookdef createExcel():    #创建一个工作薄    wb = Workbook()    #通过工作簿创建一个工作表，默认是第一个工作表    sheet = wb.active    #可以通过create_sheet来指定创建第几个sheet    #ws = wb.create_sheet(1,&apos;custom&apos;)    # excel创建的工作表名默认为sheet1    sheet.title = &apos;create_sheet&apos;    # 向工作表中输入内容(C3对应是ExcelC3的位置)    sheet[&apos;C3&apos;] = &apos;hello word&apos;    #对A列1-10输入内容    for i in range(10):      sheet[&apos;A%d&apos; % (i+1)] = i+1    # 向excel表中输入表达式 C2显示内容为A列求和    sheet[&apos;C2&apos;] = &apos;=SUM(A:A)&apos;    # 保存一个文档    wb.save(&apos;create_excel.xlsx&apos;)createExcel()</span><br></pre></td></tr></table></figure><p>这样在这个py文件的同一文件夹下，会生成一个create_excel.xlsx</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-09-%E4%B8%8A%E5%8D%8811.19.37.png" srcset="/img/loading.gif" alt="img"></p><p>3.3 读取Excel</p><p>在刚才我们创建了这个Excel文件，现在来进行读取Excel文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def loadExcel():    # 打开一个工作薄    wb = load_workbook(&apos;create_excel.xlsx&apos;,data_only=True) #data_only=True是关键，显示公式结果    # 获取一张表，需要对应那个表的name，之前取的是create_sheet    sheet=wb.get_sheet_by_name(&quot;create_sheet&quot;)    # 获取A1格的值    print(&quot;A1的值  &quot;,sheet[&apos;A1&apos;].value)    # 获取表的内容的最大工作行数    print(&quot;表最大工作行数  &quot;,sheet.max_row)    # 获取表的内容的最大工作列数    print(&quot;表最大工作列数  &quot;,sheet.max_column)    # 遍历表中所有内容    for row in sheet.rows:        #row是每一行中的数据        for cell in row:            print(cell.value,end=&quot; &quot;)        print(&quot;&quot;)        # row[2].valueloadExcel()</span><br></pre></td></tr></table></figure><p>显示结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1的值 1表最大工作行数 10表最大工作列数 31 None None 2 None 55 3 None hello word 4 None None 5 None None 6 None None 7 None None 8 None None 9 None None 10 None None</span><br></pre></td></tr></table></figure><p>通过结果，会发现最大行数和最大列数指的是我们文档中写入的数据最后一行和最后一列</p>]]></content>
    
    
    <categories>
      
      <category>Excel</category>
      
      <category>Excel-openpyxl-创建和读取</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql_docker</title>
    <link href="undefined2017/06/25/mysql-docker/"/>
    <url>2017/06/25/mysql-docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker的centos7-2下安装mysql启动容器"><a href="#docker的centos7-2下安装mysql启动容器" class="headerlink" title="docker的centos7.2下安装mysql启动容器"></a>docker的centos7.2下安装mysql启动容器</h1><p>docker run -d -it -p 805:80 -p 5002:5000 -p 10027:22 -p 20001:8888 -p 20002:3306 –name centos_master –privileged=true -v /var/run/docker.sock:/var/run/docker.sock -v /zc:/zc -e LANG=zh_CN.utf8 zhangcheng0111/centos7-webssh-dockermanager-ssh   /usr/sbin/init</p><p>进入容器</p><p>docker exec -it centos_master bash</p><p>yum install -y wget</p><p>wget -i -c <a href="http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</a></p><p>yum -y install mysql57-community-release-el7-10.noarch.rpm</p><p>yum install -y mysql-server</p><p>systemctl start  mysqld.service</p><p>systemctl status mysqld.service</p><p><code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></p><p><strong>修改**</strong>root<strong>**密码</strong></p><p>获得初始密码后，第一件事就是要重新设置root密码，否则什么事情也做不了，因为MySQL强制要求必须重新设置root密码。</p><p>进入mysql数据库</p><p><strong>修改密码</strong></p><p>mysql -uroot -p</p><p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘MyNewPass4!’;</p><p>修改外部访问权限</p><p>mysql&gt;use mysql;</p><p>mysql&gt;update user set host = ‘%’ where user = ‘root’;</p><p>mysql&gt;select host, user from user;</p><p>mysql&gt;exit</p><p>修改sql_mode模式</p><p>vi /etc/my.cnf</p><p>sql_mode=””</p><p>重启</p><p>systemctl restart mysqld.service</p><p>如果忘记密码或者找回密码</p><p>1.修改配置文件my.cfg<br>[root@localhost ~]# vi /etc/my.cnf<br>找到mysqld在之后添加<br>skip-grant-tables<br>保存退出</p><p>2.重启服务<br>service mysqld restart</p><p>3.直接登陆mysql而不需要密码<br>mysql</p><p>然后修改密码</p><p>4.在mysql中输入<br>update mysql.user set password=password(‘root’) where user=’root’;<br>（此时提示ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’）</p><p>5.（这是怎么回事？）原来是mysql数据库下已经没有password这个字段了，password字段改成了authentication_string<br>update mysql.user set authentication_string=password(‘123456′) where user=’root’ ;</p><p>6.执行</p><p>flush privileges;<br>7.退出mysql ，到/etc/my.cnf中把开始添加的skip-grant-tables去掉<br>8.重启mysql服务</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scrapy-5-文件图片下载</title>
    <link href="undefined2017/05/03/scrapy-5-%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"/>
    <url>2017/05/03/scrapy-5-%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>在scrapy中提供了2种下载通道</p><p>FilesPipeline    提供文件下载</p><p>ImagesPipline  提供图片的下载，额外提供缩略图</p><p>这2个ItemPipline作为特殊的下载器，用户使用时，只需要通过item的一个特殊字段，将要下载文件或图片url进行赋值，他们就会自动将文件或者图片下载本地。并将下载结果信息存入到item的另一个特殊字段中</p><p>FilePipline的使用</p><p>导入路径  scrapy.pipelines.files.FilesPipeline</p><p>Item字段  file_urls,files</p><p>下载目录  FILES_STORE</p><p>请看一下前端页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/book/sg.pdf'</span>&gt;</span>下载三国演义<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/book/shz.pdf'</span>&gt;</span>下载水浒传<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/book/hlm.pdf'</span>&gt;</span>下载红楼梦<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/book/xyj.pdf'</span>&gt;</span>下载西游记<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用FilePipLine通常置于其他ItemPipline之前</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;<span class="string">'scrapy.pipelines.files.FilesPipeline'</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>在配置文件setting.py中使用FILES_STORE指定文件下载目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILES_STORE=<span class="string">'/home/zhangcheng/Download/scrapy'</span></span><br></pre></td></tr></table></figure><p>在Spider解析一个包含文件下载链接的页面时，将所有需要下载的文件的url地址收集到一个列表，赋给item的file_urls字段(item[‘file_urls’]) FilesPipeline在处理每一项item时，会读取item[‘file_urls’],对其中每一个url进行下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadBookSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(response)</span>:</span></span><br><span class="line"> item=&#123;&#125;</span><br><span class="line"> <span class="comment">#下载列表</span></span><br><span class="line"> item[<span class="string">'file_urls'</span>]=[]</span><br><span class="line"> <span class="keyword">for</span> url <span class="keyword">in</span> response.xpath(<span class="string">'//a/@href'</span>).extract():</span><br><span class="line"> download_url=response.urljoin(url)</span><br><span class="line"> <span class="comment">#将url填入下载列表</span></span><br><span class="line"> item[<span class="string">'file_urls'</span>].append(download_url)</span><br><span class="line"> <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>当FilesPipeline下载完item[‘file_urls’]中的所有文件后，会将各文件的下载结果信息收集到另一个列表，赋给item的files字段(item[‘files’])，下载结果包括以下内容</p><p>Path 文件下载到本地的路径</p><p>Checksum 文件的校验和</p><p>url 文件的url地址</p><p>ImagesPipeline使用</p><p>导入路径  scrapy.pipelines.images.ImagesPipeline</p><p>Item字段  image_urls,images</p><p>下载目录  IMAGES_STORE</p><p>ImagesPipeline是在FilesPipeline基础上针对图片图片增加了一些特有功能</p><p>为图片生成缩略图</p><p>开启该功能，需要在setting中设置IMAGES_THUMBS  是一个字典，每一项的值是缩略图的尺寸</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGES_THUMBS=&#123; <span class="string">'small'</span>:(<span class="number">50</span>,<span class="number">50</span>), <span class="string">'big'</span>:(<span class="number">270</span>,<span class="number">270</span>),&#125;</span><br></pre></td></tr></table></figure><p>开启该功能后，下载一张图片，本地会出现三张图片，分别在full、thumbs/small下 thumbs/big下</p><p>过滤掉尺寸过小的图片</p><p>在setting.py中设置IMAGES_MIN_WIDTH和IMAGES_MIN_HEIGHT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGES_MIN_WIDTH=<span class="number">110</span>IMAGES_MIN_HEIGHT=<span class="number">110</span></span><br></pre></td></tr></table></figure><p>开启该功能后，如果下载了一张105<img src="https://s.w.org/images/core/emoji/11/svg/2716.svg" srcset="/img/loading.gif" alt="✖">200的图片，该图片就会被抛弃掉，因为宽度不符合</p><p>文件下载例子</p><p>爬取matplotlib网站源码文件  html解析下载文件</p><p>创建项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject matplotlib_examples</span><br></pre></td></tr></table></figure><p>到项目目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd matplotlib_examples/</span><br></pre></td></tr></table></figure><p>爬虫模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider examples matplotlib.org</span><br></pre></td></tr></table></figure><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-02-%E4%B8%8B%E5%8D%886.07.23.png" srcset="/img/loading.gif" alt="img"></p><p>编辑items.py增加模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">     file_urls=scrapy.Field()</span><br><span class="line">     files=scrapy.Field()</span><br></pre></td></tr></table></figure><p>编辑examples.py实现爬虫逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"> <span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"> <span class="keyword">from</span> matplotlib_examples.items <span class="keyword">import</span> ExampleItem</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ExamplesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">     name = <span class="string">'examples'</span></span><br><span class="line">     allowed_domains = [<span class="string">'matplotlib.org'</span>]</span><br><span class="line">     start_urls = [<span class="string">'http://matplotlib.org/examples/index.html'</span>]</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">         le =LinkExtractor(restrict_css=<span class="string">'div.toctree-wrapper.compound'</span>,deny=<span class="string">'/index.html$'</span>)</span><br><span class="line">         <span class="keyword">for</span> link <span class="keyword">in</span> le.extract_links(response):</span><br><span class="line">             <span class="keyword">yield</span> scrapy.Request(link.url,callback=self.parse_example)</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">parse_example</span><span class="params">(self,response)</span>:</span></span><br><span class="line">         href = response.css(<span class="string">'a.reference.external::attr(href)'</span>).extract_first()</span><br><span class="line">         url =response.urljoin(href)</span><br><span class="line">         example=ExampleItem()</span><br><span class="line">         print(url)</span><br><span class="line">         example[<span class="string">'file_urls'</span>]=[url]</span><br><span class="line">         <span class="keyword">return</span> example</span><br></pre></td></tr></table></figure><p>在setting.py中增加下载模块，下载模块会自动寻找file_urls字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;</span><br><span class="line">     <span class="string">'scrapy.pipelines.files.FilesPipeline'</span>:<span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line"> FILES_STORE=<span class="string">'examples_src'</span></span><br></pre></td></tr></table></figure><p>增加run.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"> <span class="keyword">from</span>  scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"> execute(<span class="string">'scrapy crawl examples -o examples.json'</span>.split())</span><br></pre></td></tr></table></figure><p>运行run.py</p><p>最后产生一个examples.json文件和一个examples_src文件夹，examples.json文件保存抓取下的数据,文件夹中保存的下载后的文件</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-02-%E4%B8%8B%E5%8D%886.08.16.png" srcset="/img/loading.gif" alt="img"></p><p>但是下载的内容，会全部保存在full这个我们指定的文件夹下，但是文件名称为一段很长的sha散列值的文件，这是为了防止文件覆盖，但是这样很不方便阅读</p><p>我们期望每个文件都存入我们指定的地方，实际上FilesPipline里面的file_path方法决定了文件名，所以就需要我们继承FilesPipline重写file_path的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"> <span class="keyword">from</span> os.path <span class="keyword">import</span>  basename,dirname,join</span><br><span class="line"> <span class="keyword">from</span> scrapy.pipelines.files <span class="keyword">import</span> FilesPipeline</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyFilePipeline</span><span class="params">(FilesPipeline)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">         path=urlparse(request.url).path</span><br><span class="line">         <span class="keyword">return</span> join(basename(dirname(path)),basename(path))</span><br></pre></td></tr></table></figure><p>在setting.py中添加的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;     <span class="comment"># 'scrapy.pipelines.files.FilesPipeline':1     'toscrape_book.pipelines.MyFilesPipeline': 300,  &#125;</span></span><br></pre></td></tr></table></figure><p>重新运行后，则展示了对应的文件在对应的文件夹下</p><p>此例子可以应用在下载对应的组图中</p><p>360图片下载项目   json+下载项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject so_image</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd so_image</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider images image.so.com</span><br></pre></td></tr></table></figure><p>使用pycharm打开</p><p>在setting.py中添加ImagesPipeline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;     </span><br><span class="line"><span class="string">'scrapy.pipelines.images.ImagesPipeline'</span>:<span class="number">1</span> </span><br><span class="line">&#125; IMAGES_STORE=<span class="string">'download_images'</span></span><br></pre></td></tr></table></figure><p>实现imagesSpider.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"> <span class="keyword">import</span> json</span><br><span class="line"> <span class="keyword">from</span> scrapy <span class="keyword">import</span>  Request</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ImagesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">     BASE_URL=<span class="string">'http://image.so.com/zj?ch=art&amp;sn=%s&amp;listtype=new&amp;temp=1'</span></span><br><span class="line">     <span class="comment">#限制最大下载量，防止磁盘用量过大</span></span><br><span class="line">     MAX_DOWNLOAD_NUM=<span class="number">1000</span></span><br><span class="line">     name = <span class="string">'images'</span></span><br><span class="line">     allowed_domains = [<span class="string">'image.so.com'</span>]</span><br><span class="line">     start_urls = [BASE_URL%<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">         <span class="comment">#使用json模块解析响应结果</span></span><br><span class="line">         infos= json.loads(response.body.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">         <span class="comment">#提取所有的图片下载url到一个列表，赋值给item的image_urls字段</span></span><br><span class="line">         <span class="keyword">yield</span> &#123;<span class="string">'image_urls'</span>:[info[<span class="string">'qhimg_url'</span>] <span class="keyword">for</span> info <span class="keyword">in</span> infos[<span class="string">'list'</span>]]&#125;</span><br><span class="line">         <span class="comment">#如count字段大于0，并且下载数据不足MAX_DOWNLOAD_NUM,继续获取下一页图片信息</span></span><br><span class="line">         self.start_index+=infos[<span class="string">'count'</span>]</span><br><span class="line">         <span class="keyword">if</span> infos[<span class="string">'count'</span>] &gt;<span class="number">0</span> <span class="keyword">and</span> self.start_index&lt;self.MAX_DOWNLOAD_NUM:</span><br><span class="line">             <span class="keyword">yield</span> Request(self.BASE_URL%self.start_index)</span><br></pre></td></tr></table></figure><p>在setting.py中设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>创建运行run.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  scrapy.cmdline <span class="keyword">import</span> execute </span><br><span class="line">execute([<span class="string">'scrapy'</span>,<span class="string">'crawl'</span>,<span class="string">'images'</span>])</span><br></pre></td></tr></table></figure><p>查看结果，可以看到下载的图片</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>scrapy-5-文件图片下载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>scrapy</tag>
      
      <tag>scrapy-5-文件图片下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="undefined2017/04/25/docker/"/>
    <url>2017/04/25/docker/</url>
    
    <content type="html"><![CDATA[<p>####Python操作docker</p><p>通过python调用docker，需要和docker在同一个服务器上才可以</p><p>也可以通过传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix:///var/run1/docker.sock</span><br></pre></td></tr></table></figure><p>来进行在容器内操作你指定想要连接的docker，这个共享需要在容器最开始创建时候，让容器和外部一个文件进行关联才可以，具体可以参照一下</p><p>docker run -d -it -p 805:80 -p 5002:5000 -p 10027:22 -p 20001:8888 -p 20002:3306 –name centos_master –privileged=true -v /var/run/docker.sock:/var/run/docker.sock -v /zc:/zc -e LANG=zh_CN.utf8 zhangcheng0111/centos7-webssh-dockermanager-ssh /usr/sbin/init</p><p>其中比较关键的是-v /var/run/docker.sock:/var/run/docker.sock  映射了容器内部和外部的关联文件</p><p>以下介绍通过python控制</p><p>官方文档地址<a href="https://github.com/docker/docker-py" target="_blank" rel="noopener">https://github.com/docker/docker-py</a>  只能作为参考，写的很简单</p><p>docker-py实际上分为很多版本，新版和旧版的api不一样，新版的删除掉了很多实用的方法，并且没有经过实际生产环境验证，无法得知具体使用效果，这里所说的是基于旧版的1.19版本</p><p>安装docker-py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-py</span><br></pre></td></tr></table></figure><p><img src="http://47.93.248.15/wp-content/uploads/2018/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-07-20-%E4%B8%8B%E5%8D%887.17.30.png" srcset="/img/loading.gif" alt="img"></p><p>一、初始化docker客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import docker</span><br></pre></td></tr></table></figure><p>#初始化有2种方式都可以</p><p>#第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = docker.Client(base_url=&apos;unix:///var/run/docker.sock&apos;,version=&apos;1.19&apos;)</span><br></pre></td></tr></table></figure><p>其中version指定使用的版本，很重要！！！一定不能少</p><p>#第二种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client=docker.from_env(version=&apos;1.19&apos;)</span><br></pre></td></tr></table></figure><p>#推荐使用第一种方式</p><p>二、获得镜像信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(clinet.images())</span><br></pre></td></tr></table></figure><p>返回的数据是列表形式</p><p>拉去镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(clinet.pull(&apos;zhangcheng0111/centos7-webssh-dockermanager-ssh&apos;))</span><br></pre></td></tr></table></figure><p>三、根据镜像创建一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create_container(image=&apos;zhangcheng0111/centos7-webssh-dockermanager-ssh&apos;, name=&apos;test3&apos;,                             ports=[50070,8088,9000,3306,9999,16010,22,5000,8080,80,8888], command=&quot;/usr/sbin/init&quot;,                             environment=&#123;&quot;LANG&quot;: &quot;zh_CN.utf8&quot;&#125;,                             hostname=&apos;zc01&apos;,                             host_config=self.client.create_host_config(privileged=True,port_bindings=dic1))</span><br></pre></td></tr></table></figure><p>参数说明</p><p>image=’zhangcheng0111/centos7-webssh-dockermanager-ssh’  是你pull的镜像,这个镜像的地址会从hub.docker.com上查找对应的镜像</p><p>name=’test3′   很重要，以后启动容器就靠它了</p><p>command=’/usr/sbin/init’ 启动镜像后的命令行，实际上就是进行一些基础服务的启动</p><p>volumes=[‘/data’]  数据卷，相当于数据在哪保存，路径是宿主机的，这里没有使用</p><p>environment={“LANG”: “zh_CN.utf8”}  设定一些参数</p><p>ports=[80,22]   额外开启哪些端口</p><p>privileged=True 设置特权启动，让你容器具备这个容器的root权限</p><p>port_bindings=dic1 设定具体内部和外部端口的映射{’80’:None}如果采用None，则docker会自动进行分配端口，如果自己手动指定，需要注意不要端口冲突，否则会创建失败的</p><p>如果自动分配了，我们如何获得这个容器的外部映射端口号呢？后面会说如何查看这个容器配置，包括内网ip和外网ip</p><p>这样我们就创建了一个容器，创建了容器还没有开启</p><p>四、获得所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(client.containers(all=True))</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;u&apos;Status&apos;: u&apos;Exited (0) About a minute ago&apos;, u&apos;Created&apos;: 1532098433, u&apos;Image&apos;: u&apos;sequenceiq/spark:1.6.0&apos;, u&apos;Labels&apos;: &#123;&#125;, u&apos;NetworkSettings&apos;: &#123;u&apos;Networks&apos;: &#123;u&apos;bridge&apos;: &#123;u&apos;NetworkID&apos;: u&apos;66af7ecb2d04d21dba5bb003a21c2adad034430315cc380fff718c9d7f6e29c3&apos;, u&apos;MacAddress&apos;: u&apos;&apos;, u&apos;GlobalIPv6PrefixLen&apos;: 0, u&apos;Links&apos;: None, u&apos;GlobalIPv6Address&apos;: u&apos;&apos;, u&apos;IPv6Gateway&apos;: u&apos;&apos;, u&apos;DriverOpts&apos;: None, u&apos;IPAMConfig&apos;: None, u&apos;EndpointID&apos;: u&apos;&apos;, u&apos;IPPrefixLen&apos;: 0, u&apos;IPAddress&apos;: u&apos;&apos;, u&apos;Gateway&apos;: u&apos;&apos;, u&apos;Aliases&apos;: None&#125;&#125;&#125;, u&apos;HostConfig&apos;: &#123;u&apos;NetworkMode&apos;: u&apos;default&apos;&#125;, u&apos;ImageID&apos;: u&apos;sha256:40a687b3cdccd2224016c07a5ca20aeca0d0ef9f397d11ae6102ee1245d915d6&apos;, u&apos;State&apos;: u&apos;exited&apos;, u&apos;Command&apos;: u&apos;/etc/bootstrap.sh&apos;, u&apos;Names&apos;: [u&apos;/test3&apos;], u&apos;Mounts&apos;: [], u&apos;Id&apos;: u&apos;d322d097f34c0c18cec0a3dcc863ace22ac14c07e4ff3aaeb4f52816e9a87f69&apos;, u&apos;Ports&apos;: []&#125;, &#123;u&apos;Status&apos;: u&apos;Exited (0) 2 hours ago&apos;, u&apos;Created&apos;: 1532097805, u&apos;Image&apos;: u&apos;sequenceiq/spark:1.6.0&apos;, u&apos;Labels&apos;: &#123;&#125;, u&apos;NetworkSettings&apos;: &#123;u&apos;Networks&apos;: &#123;u&apos;bridge&apos;: &#123;u&apos;NetworkID&apos;: u&apos;66af7ecb2d04d21dba5bb003a21c2adad034430315cc380fff718c9d7f6e29c3&apos;, u&apos;MacAddress&apos;: u&apos;&apos;, u&apos;GlobalIPv6PrefixLen&apos;: 0, u&apos;Links&apos;: None, u&apos;GlobalIPv6Address&apos;: u&apos;&apos;, u&apos;IPv6Gateway&apos;: u&apos;&apos;, u&apos;DriverOpts&apos;: None, u&apos;IPAMConfig&apos;: None, u&apos;EndpointID&apos;: u&apos;&apos;, u&apos;IPPrefixLen&apos;: 0, u&apos;IPAddress&apos;: u&apos;&apos;, u&apos;Gateway&apos;: u&apos;&apos;, u&apos;Aliases&apos;: None&#125;&#125;&#125;, u&apos;HostConfig&apos;: &#123;u&apos;NetworkMode&apos;: u&apos;default&apos;&#125;, u&apos;ImageID&apos;: u&apos;sha256:40a687b3cdccd2224016c07a5ca20aeca0d0ef9f397d11ae6102ee1245d915d6&apos;, u&apos;State&apos;: u&apos;exited&apos;, u&apos;Command&apos;: u&apos;/etc/bootstrap.sh&apos;, u&apos;Names&apos;: [u&apos;/test2&apos;], u&apos;Mounts&apos;: [], u&apos;Id&apos;: u&apos;089dbc622b0409ed70fb6c2bdf735e0edc70282aa2c7f4d0d6b4092d74aa05be&apos;, u&apos;Ports&apos;: []&#125;, &#123;u&apos;Status&apos;: u&apos;Exited (137) 2 hours ago&apos;, u&apos;Created&apos;: 1532097064, u&apos;Image&apos;: u&apos;sequenceiq/spark:1.6.0&apos;, u&apos;Labels&apos;: &#123;&#125;, u&apos;NetworkSettings&apos;: &#123;u&apos;Networks&apos;: &#123;u&apos;bridge&apos;: &#123;u&apos;NetworkID&apos;: u&apos;66af7ecb2d04d21dba5bb003a21c2adad034430315cc380fff718c9d7f6e29c3&apos;, u&apos;MacAddress&apos;: u&apos;&apos;, u&apos;GlobalIPv6PrefixLen&apos;: 0, u&apos;Links&apos;: None, u&apos;GlobalIPv6Address&apos;: u&apos;&apos;, u&apos;IPv6Gateway&apos;: u&apos;&apos;, u&apos;DriverOpts&apos;: None, u&apos;IPAMConfig&apos;: None, u&apos;EndpointID&apos;: u&apos;&apos;, u&apos;IPPrefixLen&apos;: 0, u&apos;IPAddress&apos;: u&apos;&apos;, u&apos;Gateway&apos;: u&apos;&apos;, u&apos;Aliases&apos;: None&#125;&#125;&#125;, u&apos;HostConfig&apos;: &#123;u&apos;NetworkMode&apos;: u&apos;default&apos;&#125;, u&apos;ImageID&apos;: u&apos;sha256:40a687b3cdccd2224016c07a5ca20aeca0d0ef9f397d11ae6102ee1245d915d6&apos;, u&apos;State&apos;: u&apos;exited&apos;, u&apos;Command&apos;: u&apos;/etc/bootstrap.sh&apos;, u&apos;Names&apos;: [u&apos;/test1&apos;], u&apos;Mounts&apos;: [], u&apos;Id&apos;: u&apos;a6b4592de281345d4f5c7e3c7254048214fdeb9581bba13d37aa612cfeff7a8d&apos;, u&apos;Ports&apos;: []&#125;]</span><br></pre></td></tr></table></figure><p>五、开启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.statr(container=&apos;test3&apos;,port_bindings=&#123;80:80,22:2022&#125;)</span><br></pre></td></tr></table></figure><p>container=’test3′ 创建容器设置的name，用于开启容器<br>port_bindings={80:80,22:2022} 设置容器与宿主机端口之间的映射关系，这里port_bindings我测试过只能修改在你创建时候设定的端口，如果没有开放的端口，则无法修改，所以在这里一般没什么卵用<br>publish_all_ports=True  全端口公开，会依次进行映射外部访问<br>以下参数，没搞明白是干啥的<br>lxc_conf=None  不知道啥意思<br>links=None<br>privileged=False<br>dns=None<br>dns_search=None<br>volumes_from=None<br>network_mode=None<br>restart_policy=None<br>cap_add=None<br>cap_drop=None</p><p>六、停止容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.stop(container=&apos;test3&apos;)</span><br></pre></td></tr></table></figure><p>七、查看容器的具体参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item = self.client.containers(filters=&#123;&apos;name&apos;: &apos;test3&apos;&#125;)[0]# 遍历获得对应的容器的ip和端口  22和8888的映射端口 ip = item[&apos;NetworkSettings&apos;][&apos;Networks&apos;][&apos;bridge&apos;][&apos;IPAddress&apos;]with open(&quot;/zc/ip.txt&quot;) as f:    wip = f.read().strip(&quot;\n&quot;)print(&apos;外网地址&apos;, wip)print(&apos;内网地址&apos;, ip)# 对应key-value是数字# 遍历获得对应的容器的ip和端口  22和8888的映射端口for port in item[&apos;Ports&apos;]:    dic[port[&apos;PrivatePort&apos;]] = port.get(&apos;PublicPort&apos;)</span><br></pre></td></tr></table></figure><p>通过以上我们不难看出通过返回的数据，可以遍历里面的ip地址</p><p>至于/zc/ip.txt是这个什么鬼？这个是我外部与内部共享的一个文件，用于获得外部的ip地址，因为容器本身只能获得自己的内网ip地址，无法得知外网地址</p>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scrapy-4-链接提取器</title>
    <link href="undefined2017/04/05/scrapy-4-%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%96%E5%99%A8/"/>
    <url>2017/04/05/scrapy-4-%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%96%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>链接提取器，设置规则后，进行批量提取所有连接，主要用于是在CrawlSpider模板中使用的居多</p><p>比如提取某个网站上所有数据</p><p>使用LinkExtractor需要添加相关头文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br></pre></td></tr></table></figure><p>以下代码进行整站爬取。通过Rule+LinkExtractor结合进行提取了所有页面的数据，CrawlSpider想进行整站所有a标签提取，但是Rule+LinkExtractor进行了限制，筛选出符合我规则的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItcastSpider</span><span class="params">(scrapy.spiders.CrawlSpider)</span>:</span></span><br><span class="line">     name = <span class="string">'book'</span></span><br><span class="line">     start_urls = [<span class="string">'http://books.toscrape.com/'</span>]</span><br><span class="line">     img_urls = []</span><br><span class="line">     rules = (Rule(LinkExtractor(allow=(<span class="string">'http://books.toscrape.com/catalogue/page-\d&#123;1,6&#125;'</span>+<span class="string">'.html'</span>,)),</span><br><span class="line">                  callback=<span class="string">'parse_item'</span>, follow=<span class="literal">True</span>),)</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span><span class="params">(self,response)</span>:</span></span><br><span class="line">         print(<span class="string">"收到数据"</span>)</span><br></pre></td></tr></table></figure><p>注意：连接提取器中的里面的逗号是不能少的，因为Rule接受的是一个可迭代的对象元组</p><p>这个方法比较适合对整站数据的规则爬取，不需要自己设置反复爬取的地址了</p><p>LinkExtractor相关参数说明</p><p>allow  接收一个正则表达式的地址，用于过滤出符合条件的地址</p><p>deny  与allow相反，接收一个正则表达式，排除符合条件的地址</p><p>allow_domains 接收一个域名或一个域名列表，提取到指定域的链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line">domains=[<span class="string">'github.com'</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">le = LinkExtractor(allow_domains=domains)</span><br><span class="line">links = le.extract_links(response)</span><br><span class="line">[link.url <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br></pre></td></tr></table></figure><p>其中response是获得请求后的结果</p><p>deny_domains 与allow_domains相反，排除指定域的连接</p><p>restruct_xpaths 接收一个XPath表达式</p><p>提取指定页面下的<div id="”top”">元素下的所有链接</div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line">le = LinkExtractor(restruct_xpaths=<span class="string">'//div[@id="top"]'</span>)</span><br><span class="line">links = le.extract_links(response)</span><br><span class="line">[link.url <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br></pre></td></tr></table></figure><p>其中response是获得请求后的结果</p><p>restruct_css 接收一个css选择器或者选择器列表</p><p>提取指定页面下<div id="”bottom”">下的链接</div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line">le = LinkExtractor(restruct_css=<span class="string">'div#bottom"]'</span>)</span><br><span class="line">links = le.extract_links(response)</span><br><span class="line">[link.url <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br></pre></td></tr></table></figure><p>提取JavaScript文件的连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line">le = LinkExtractor(tags=<span class="string">'script'</span>,attrs=<span class="string">'src'</span>)</span><br><span class="line">links = le.extract_links(response)</span><br><span class="line">[link.url <span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br><span class="line">process_value</span><br></pre></td></tr></table></figure><p>接收一个函数，用于处理连接地址，如果返回none则抛弃这个地址</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>scrapy-4-链接提取器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>scrapy</tag>
      
      <tag>scrapy-4-链接提取器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django序列化器问题</title>
    <link href="undefined2017/03/25/python/"/>
    <url>2017/03/25/python/</url>
    
    <content type="html"><![CDATA[<p>序列化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoSerializer</span><span class="params">(serializers.Serializer)</span>:</span>    </span><br><span class="line">    <span class="string">"""图书数据序列化器"""</span>    </span><br><span class="line">    id = serializers.IntegerField(label=<span class="string">'ID'</span>, read_only=<span class="literal">True</span>)    </span><br><span class="line">    btitle = serializers.CharField(label=<span class="string">'名称'</span>, max_length=<span class="number">20</span>)    </span><br><span class="line">    bpub_date = serializers.DateField(label=<span class="string">'发布日期'</span>, required=<span class="literal">False</span>)    </span><br><span class="line">    bread = serializers.IntegerField(label=<span class="string">'阅读量'</span>, required=<span class="literal">False</span>)    </span><br><span class="line">    bcomment = serializers.IntegerField(label=<span class="string">'评论量'</span>, required=<span class="literal">False</span>)    </span><br><span class="line">    image = serializers.ImageField(label=<span class="string">'图片'</span>, required=<span class="literal">False</span>)<span class="comment">#     在这里一的一方定义外键    heroinfo_set = serializers.PrimaryKeyRelatedField(read_only=True)</span></span><br></pre></td></tr></table></figure><p>以上会报错，原因是</p><p>在定义外部的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroinfo_set = serializers.PrimaryKeyRelatedField(read_only=True,many=True)</span><br></pre></td></tr></table></figure><p>需要添加many=True</p><p>Django视图集的使用</p><p>视图集的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixinsfrom </span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSetclass BookInfoViewSet(mixins.ListModelMixin,mixins.RetrieveModelMixin,GenericViewSet):    </span><br><span class="line">    <span class="string">"""使用GenericViewSet实现返回列表和单一值"""</span>     </span><br><span class="line">    <span class="comment"># 指定序列化器    serializer_class =  BookInfoSerializer    </span></span><br><span class="line">    <span class="comment"># 制定查询集    queryset = BookInfo.objects.all()</span></span><br></pre></td></tr></table></figure><p>视图集的加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^books/$&apos;, new_views.BookInfoViewSet.as_view(&#123;&apos;get&apos;:&apos;list&apos;&#125;)),url(r&apos;^books/(?P&lt;pk&gt;\d+)/$&apos;, new_views.BookInfoViewSet.as_view(&#123;&apos;get&apos;:&apos;retrieve&apos;&#125;)),</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scrapy-3-数据处理</title>
    <link href="undefined2017/03/02/scrapy-3-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>2017/03/02/scrapy-3-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>####itemPipeline数据处理</p><p>介绍</p><p>启动方式</p><p>导出数据</p><p>一、介绍</p><p>在scrapy中，数据经过spider请求解析后，就需要进行对应模型化处理，在scrapy中itemPipeline负责数据处理</p><p>   itemPipeline相当于数据处理的过滤器一样，可以配置多个，每一个itemPipline处理完成return后，会进入下一个itemPipeline中，如果不return，则表示放弃这段数据</p><p>   每一个itemPipeline中，需要实现process_item(self,item,spider):这个方法，在这个方法中进行处理数据</p><p>   open_spider(self,spider) 一般Spider打开时，回调该方法，通常用于处理数据之前的某些初始化工作，比如连接数据库</p><p>   close_spider(self,spider)一般Spider关闭时，回调该方法，通常用于处理完成所有数据之后，如关闭数据库</p><p>   from_crawler(cls,crawler) 一般没啥用，创建ItemPipeline对象时候回调该类方法</p><p>二、启动方式</p><p>启动方式有2种方式，一种在setting.py进行配置，一种在爬虫文件中配置</p><p>方式1 在setting.py中进行配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;<span class="string">'example.pipelines.PriceConverterPipeline'</span>:<span class="number">300</span>&#125;</span><br></pre></td></tr></table></figure><p>example是工程名字，pipelines是所在文件夹，PriceConverterPipeline自定义的itemPipeline，300是优先级，数值越小优先度越大</p><p>多个ItemPipLine的应用，可以使用去重操作，在自定义的ItemPipLine中init初始化时候，初始一个set集合，在每次响应process_item时候对比name，从set中进行对比即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplicatesPipeline</span><span class="params">(object)</span>:</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        self.book_set=set()   </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self,item,spider)</span>:</span>      </span><br><span class="line">            name=item[<span class="string">'name'</span>]      </span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self.book_set:      </span><br><span class="line">                <span class="comment">#数据重复不进行返回即可      </span></span><br><span class="line">                self.book_sett.add(name)      </span><br><span class="line">                <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>建立完成DuplicatesPipeline后需要在Setting.py中配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;<span class="string">'example.pipelines,PriceConverterPipeline'</span>:<span class="number">300</span>,<span class="string">'example.pipelines.TestPipeline'</span>:<span class="number">400</span>,&#125;</span><br></pre></td></tr></table></figure><p>方式2 在Spider文件中可以指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Spider1(scrapy.Spider):     </span><br><span class="line">    name = <span class="string">'book1'</span>     </span><br><span class="line">    custom_settings = &#123;     <span class="string">'ITEM_PIPELINES'</span>:&#123;<span class="string">'pipelineClass1'</span>: <span class="number">300</span>,<span class="string">'pipelineClass2'</span>: <span class="number">400</span>&#125;,                   &#125;</span><br></pre></td></tr></table></figure><p>这样可以解决多个Spider1时候指定ITEM_PIPELINES的问题，可以为每一个Spider指定数据处理的方式</p><p>需要注意的是最后一个ItemPipLine处理完成后，会根据命令行来进行处理后输出到哪里</p><p>scrapy crawl books -o books.csv</p><p>以上这段命令行中的-o books.csv是写入的文件，就是在最后一个ItemPipeline最后return的数据</p><p><strong>四、数据导出</strong></p><p>scrapy默认导出数据支持5种方式</p><p>JSON   JsonItemExporter</p><p>JSON lines   JsonLinesItemExporter</p><p>CSV  CsvItemExporter</p><p>XML  XmlItemExporter</p><p>Pickle  PickleItemExporter</p><p>Marshal MarsshallItemExporter</p><p>前4种是极为常用的文本数据格式，后面2种是Python特有的，scrapy本身没有准备Excel格式数据导出</p><p>如何导出？</p><p>方式一   命令行参数</p><p>-o -t参数指定导出文件路径和导出格式，通常t可以由o进行推测完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books -o books.csv</span><br></pre></td></tr></table></figure><p>scrapy crawl 是固定的</p><p>books是spider中的name</p><p>-o是输出的路径</p><p>books.csv 没有指定其他路径，就是在当前路径下，没有使用o,但是会根据提供的路径，推测出是csv</p><p>以下是指定明确的输出格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books -t json -o books.data</span><br></pre></td></tr></table></figure><p>这种数据导出，是依赖什么来进行完成的？</p><p>在配置字典FEED_EXPORTERS中搜索Exporter，FEED_EXPORTERS的内容中搜索Exporter，FEED_EXPORTERS的内容由以下二个字典的内容合并而成</p><p>默认配置文件中的FEED_EXPORTERS_BASE</p><p>用户配置文件中的FEED_EXPORTERS</p><p>前者包含内部支持的数据格式，后者包含用户自定义的导出数据格式，以下是Scrapy源码中定义的FEED_EXPORTERS_BASE，它位于scrapy.settings.default_settings模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORTERS_BASE=&#123;<span class="string">'json'</span>:<span class="string">'scrapy.exporters.JsonItemExporter'</span>,<span class="string">'jsonlines'</span>:<span class="string">'scrapy.exporters.JsonLinesItemExporter'</span>,<span class="string">'jl'</span>:<span class="string">'scrapy.exporters.JsonLinesItemExporter'</span>,<span class="string">'csv'</span>:<span class="string">'scrapy.exporters.CsvItemExporter'</span>,<span class="string">'xml'</span>:<span class="string">'scrapy.exporters.XmlItemExporter'</span>,<span class="string">'marshal'</span>:<span class="string">'scrapy.exporters.MarshalItemExporter'</span>,<span class="string">'pickle'</span>:<span class="string">'scrapy.exporters.PickleItemExporter'</span>,&#125;</span><br></pre></td></tr></table></figure><p>在这里严重不建议修改源码，因为程序最终是要配置在服务器上面的，服务器上面的环境修改源码，可就没那么简单了</p><p>用户添加新的导出格式，通常是在配置文件setting.py中定义FEED_EXPORTERS，比如导出Excel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORTERS=&#123;<span class="string">'excel'</span>:<span class="string">'my_project.my_exporters.ExcelItemExporter'</span>&#125;</span><br></pre></td></tr></table></figure><p>指定导出文件路径，支持%(name)s和%(time)s这2个特殊变量</p><p>%(name)s 会被替换为Spider的名字</p><p>%(time)s 会被替换为文件创建时间</p><p>假设一个项目爬取的有书籍、游戏信息、新闻3个spider</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books  -o <span class="string">'/export_data/%(name)s/%(time)s.csv'</span></span><br><span class="line">scrapy crawl games  -o <span class="string">'/export_data/%(name)s/%(time)s.csv'</span></span><br><span class="line">scrapy crawl news  -o <span class="string">'/export_data/%(name)s/%(time)s.csv'</span></span><br></pre></td></tr></table></figure><p>以上是爬取的内容，根据书名存放在export_data文件夹下的对应书名目录下，每个目录下根据时间进行保存</p><p>方式二 配置文件方式</p><p>在setting.py中设置以下参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FEED_URI=<span class="string">'export_data/%(name)s.data'</span>            导出数据的位置</span><br><span class="line">FEED_FORMAT=<span class="string">'csv'</span>                               导出数据的格式</span><br><span class="line">FEED_EXPORT_ENCODING=<span class="string">'gbk'</span>                      导出数据的编码</span><br><span class="line">FEED_EXPORT_FIELDS=[<span class="string">'name'</span>,<span class="string">'author'</span>,<span class="string">'price'</span>]    导出数据的字段</span><br><span class="line">FEED_EXPORTERS=&#123;<span class="string">'excel'</span>:<span class="string">'my_project.my_exporters.ExcelItemExporter'</span>&#125;   新添加导出的格式</span><br></pre></td></tr></table></figure><p>如何实现一个自定义的导出的Excel类</p><p>1、继承BaseItemExporter</p><p>其中有3个方法</p><p>export_item(self,item) 负责导出爬取的每一项数据，参数item为一项爬取的数据，每一个子类必须实现该方法</p><p>start_exporting(self)   在导出开始时被调用，可在该方法执行某些初始化工作</p><p>finish_exporting(self) 在导出完成时候被调用，可在该方法中执行某些清理工作</p><p>以下实现一个导出Excel,注意这里使用的是xlwt，这个库最多只能在一个sheet中插入65535行数据，如果要插入更多数据，需要切换为openxl来进行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> BaseItemExporter</span><br><span class="line"> </span><br><span class="line">impoort xlwt</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelItemExporter</span><span class="params">(BaseItemExporter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,file,**kwargs)</span>:</span></span><br><span class="line">       self._configure(kwargs)</span><br><span class="line">       self.file=file</span><br><span class="line">       self.wbook=xlwt.Workbook()</span><br><span class="line">       self.wsheet=self.wbook.add_sheet(<span class="string">'scrapy'</span>)</span><br><span class="line">       self.row=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish_exporting</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.wbook.save(self.file)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">export_item</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        fields=self._get_serialized_fields(item)</span><br><span class="line">    <span class="keyword">for</span> col,v <span class="keyword">in</span> enumerate(x <span class="keyword">for</span> _,x <span class="keyword">in</span> fields):</span><br><span class="line">        self.wsheet.write(self.row,col,v)</span><br><span class="line"> </span><br><span class="line">    self.row +=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>编写完成后再setting.py中添加这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORTERS=&#123;<span class="string">'excel'</span>:<span class="string">'my_project.my_exporters.ExcelItemExporter'</span>&#125;</span><br></pre></td></tr></table></figure><p>之后终端命令行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books -t excel -o books.xls</span><br></pre></td></tr></table></figure><p>这样就导出excel了，当然你可以封装一个Excel导出类，这样可以更加通用，在web框架下，爬虫框架下都可以使用</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>scrapy-3-数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>scrapy</tag>
      
      <tag>scrapy-3-数据处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scrapy-2-数据解析</title>
    <link href="undefined2017/02/27/scrapy-2-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <url>2017/02/27/scrapy-2-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>1、Request和Respose对象</p><p>2、Selector对象</p><p>3、xpath使用</p><p>4、css选择器</p><p>一、Request和Respose对象</p><p><strong>1.1 Request对象</strong></p><p>Request对象是要请求一个连接所使用的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request(url[,call,method=‘GET’,headers,body,cookies,meta,encoding=‘utf<span class="number">-8</span>’,priority=<span class="number">0</span>,dont_filter=<span class="literal">False</span>,errback])</span><br></pre></td></tr></table></figure><p>Url是请求地址</p><p>callback是页面回调地址</p><p>method是请求方法，get或者post</p><p>headers是请求头</p><p>body是html正文</p><p>cookies字典类型</p><p>Meta字典类型</p><p>encoding是编码格式</p><p>priority优先级 0是最高级</p><p>dont_filter=False对重复地址自动过滤，如果设置为True会强制请求，适合重复地址随时间变化的</p><p>errback请求错误</p><p><strong>1.2 Respose对象</strong></p><p>Respose对象是当发起请求后，返回的对象，比如下列代码中parse参数中的response</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSpider</span><span class="params">(scrapy.spiders.Spider)</span>:</span>     </span><br><span class="line">    name = <span class="string">'book'</span>     </span><br><span class="line">    start_urls = [<span class="string">'http://books.toscrape.com/'</span>]     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self,response)</span>:</span>         </span><br><span class="line">        print(<span class="string">"收到数据"</span>)</span><br></pre></td></tr></table></figure><p>Url  响应地址</p><p>status 状态码</p><p>headers 获得响应头</p><p>Body 响应的正文  bytes类型</p><p>Text 文本形式str类型，是有body解码获得的，</p><p>实现方式response.text=respose.body.decode(response.encoding)</p><p><strong>1.3 start_request(self)方法</strong></p><p>当start_urls这个数组无法满足你，你就需要自定义这个start_urls，通过重写start_request的方法来完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demoSpider</span><span class="params">(RedisSpider)</span>:</span>    </span><br><span class="line">    name = <span class="string">"demospider"</span>    </span><br><span class="line">    redis_key = <span class="string">'demospider:start_urls'</span>    </span><br><span class="line">    start_urls = [<span class="string">'http://www.example.com'</span>]    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        pages=[]        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):            </span><br><span class="line">            url=<span class="string">'http://www.mmonly.cc/mmtp/xgmn/126808_%s.html'</span> % i           page=scrapy.Request(url)            </span><br><span class="line">            pages.append(page)        </span><br><span class="line">            <span class="keyword">return</span> pages</span><br></pre></td></tr></table></figure><p>注意:这个start_request只会调用一次,并且在重写了start_request后，start_urls就无效了</p><p>二、Selector对象</p><p>Html转换为对象，转换方法有很多种  BeautifulSoup  lxml</p><p>在scrapy中自带selector 可以对html的字符串进行格式</p><p>比如text是我们的html字符串</p><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line">text=<span class="string">"&lt;html&gt;&lt;body&gt;今天天气很好&lt;/body&gt;&lt;/html&gt;"</span></span><br><span class="line">selector = Selector(text=text)</span><br></pre></td></tr></table></figure><p>这样就可以对selector使用xpath和css方法读取数据了</p><p>//h1  选中文档内所有的h1标签</p><p>text()  获得text属性值</p><p>.//li/b/text() 获得当前标签下的所有li下的b标签的text</p><p>提取内容</p><p>extract、re    这2个返回数组内容</p><p>extract_first、re_first 这2个返回第一个标签内容</p><p>具体实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得当前标签下的h1下的text内容</span></span><br><span class="line">response.xpath(<span class="string">'.//h1/text()'</span>).extrat()</span><br></pre></td></tr></table></figure><p>注：Selector主要是在后面使用requests对获得html解析的时候使用的，单纯使用scrapy的时候，是不需要去手动创建Selector</p><p>三、xpath基本使用</p><p>3.1 xpath语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/  选中文档的根    </span><br><span class="line">. 选中当前节点     </span><br><span class="line">.. 选中当前节点的父节点ELEMENT 选中子节点的所有ELEMENT元素节点</span><br><span class="line">//ELEMENT 选中后代节点中所有ELEMENT元素节点</span><br><span class="line">* 选中所有元素子节点  不常用</span><br><span class="line">text()选中所有文本子节点</span><br><span class="line"><span class="meta">@ATTR 选中所有属性节点</span></span><br><span class="line"><span class="meta">@* 选中所有属性节点  不常用</span></span><br><span class="line">[谓语]  谓语用来查找某个特定的节点或者包含某个特定值的节点</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/body/div/a    选取body下的div下的a标签</span><br><span class="line">//a               基于当前节点下提取所有a标签</span><br><span class="line">/body//img   在body下的所有img标签</span><br><span class="line">//a/text()      获得所有a标签下的文字节点</span><br><span class="line">/body/div//*  选中div下的所有后代元素，一般结合后续筛选,不会作为单独使用</span><br><span class="line">//div/*/img 获得div孙节点下所有的img标签</span><br><span class="line">//img/@src  选中所有img的src属性</span><br><span class="line">//@href  选中文档中所有的ATTR属性</span><br><span class="line">//a[<span class="number">1</span>]/img/@*  获得第一个a下的img的所有属性</span><br><span class="line">.  用来描述当前节点，也就是表示一个相对路径</span><br><span class="line">.. 用来获得上一层节点的路径</span><br><span class="line">//img/..  获得所有img，读取img上一层的节点</span><br><span class="line">//a[last()] 获得所有的a标签，选中最后一个</span><br><span class="line">//a[position()&lt;=<span class="number">3</span>] 使用position()  选中前三个</span><br><span class="line">//div[@id] 选中所有包含id属性的div</span><br><span class="line">//div[@id=images]  选择所有id属性，且值为images的div</span><br></pre></td></tr></table></figure><p>注意:/和//的区别  在于/是基于当前节点下，不会继续向下穿透其他节点，而//会向下穿透获得所有这个节点</p><p>3.2 XPath常用函数</p><p>string</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sel.xpath(<span class="string">'/body/a//text()'</span>)  获得的是每个a标签内容</span><br><span class="line">sel.xpath(<span class="string">'string(/body/a)'</span>)   string是把每个a标签内容进行拼接</span><br></pre></td></tr></table></figure><p><strong>四、CSS选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 选中所有元素</span><br><span class="line">p  选中p元素</span><br><span class="line">div,p 选中div和p元素</span><br><span class="line">div p  选中div后代元素中的p元素</span><br><span class="line">div&gt;p  选中div子元素中的p元素</span><br><span class="line">p+div  选中p标签的兄弟元素中的div元素</span><br><span class="line">.info    选中class属性包含info的元素</span><br><span class="line">#main  选中id属性为main的元素</span><br><span class="line">[href]   选中属性为href的元素</span><br><span class="line">[href='www.baidu.com'] 选中属性为href元素，并且值为www.baidu.com的元素</span><br><span class="line">[href~='baidu'] 选中属性为href元素，并且值包含为baidu的元素</span><br><span class="line">p::text  选中p元素的文本节点</span><br><span class="line">a:nth-child(1)  选中a元素，且该元素必须是其父元素的第1个子元素</span><br><span class="line">a:nth-last-child(2)  选中a元素，且该元素必须是其父元素的倒数第2个子元素</span><br><span class="line">a:first-child(1) 选中a元素，且该元素必须是其父元素的第1个子元素</span><br><span class="line">a:last-child(2)  选中a元素，且该元素必须是其父元素的倒数第2个子元素</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得当前li标签下的text    </span></span><br><span class="line">response.css(<span class="string">'li::text'</span>).extrat()</span><br></pre></td></tr></table></figure><p>在下一章节介绍数据解析完成后，如何处理</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>scrapy-2-数据解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>scrapy</tag>
      
      <tag>scrapy-2-数据解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署Django</title>
    <link href="undefined2017/01/26/docker%E9%83%A8%E7%BD%B2Django/"/>
    <url>2017/01/26/docker%E9%83%A8%E7%BD%B2Django/</url>
    
    <content type="html"><![CDATA[<p>一、安装docker</p><p>二、拉取镜像</p><p>三、运行镜像，映射端口</p><p>四、安装容器内运行环境</p><p>五、主机与容器间资源传输</p><p>六、容器安装+配置 uwsgi</p><p>七、容器安装+ 配置nginx</p><p>八、负载均衡</p><p>九、Docker提交保存镜像</p><p>十、坑点</p><p>#######################################################################</p><p>前言</p><p>Django部署流程如下</p><p>1、docker安装</p><p>2、拉取centos镜像或者Ubuntu镜像  看你用哪个</p><p>3、使用镜像，run出来一个容器A</p><p>4、进入容器A，安装uwsgi，把Django部署在下面</p><p>5、在启动脚本中配置开机自启动脚本(这步有点难，需要命令方面需要使用特权)</p><p>6、提交容器A成为新镜像，run这个新镜像为容器，项目就部署完成</p><p>6、在使用centos镜像或者Ubuntu镜像，run一个容器B，在容器B中安装nginx，配置nginx转发地址即可完成部署</p><p>说明</p><p>1、在以后项目迁移到任何操作系统下通吃</p><p>2、多并发时候，可以通过run多个容器A,在配置nginx即可完成</p><p>#######################################################################</p><p>环境：</p><p>主机环境：windows 10专业版</p><p>一、安装docker</p><p>Hub.docker.com官网下载 docker for windows</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.38.50.png" srcset="/img/loading.gif" alt="img"></p><p>安装完成后，任务栏会</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.39.41.png" srcset="/img/loading.gif" alt="img"></p><p>表示已经运行起来，使用注册的账号进行</p><p>登录，显示docker is running表示windows环境下已经开始运行</p><p>注意：注册账号需要你翻墙才可以，因为那个校验码是需要谷歌的一个api</p><p>二、拉取镜像</p><p>Docker 在 windows下安装完成后会同时安装一个shell环境</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.41.53.png" srcset="/img/loading.gif" alt="img"></p><p>与cmd功能一样</p><p>使用 docker  images 查看当前有哪些镜像文件</p><p>在hub.docker.com上选择好镜像后</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.42.42.png" srcset="/img/loading.gif" alt="img"></p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.42.55.png" srcset="/img/loading.gif" alt="img"></p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.43.05.png" srcset="/img/loading.gif" alt="img"></p><p>使用镜像的 pull 命令就可以进行下载</p><p>下载完成就可以使用 docker images看到下载到本地的镜像文件</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.45.08.png" srcset="/img/loading.gif" alt="img"></p><p>三、运行镜像，映射端口</p><p>启动镜像，在启动镜像的时候可以进行端口映射</p><p>启动命令：</p><p>docker run -d -it -p 805:80 -p 5002:5000 -p 10027:22 -p 20001:8888 -p 8001:8000 –name centos-django –privileged=true -e LANG=zh_CN.utf8 licw1986/centos-django /usr/sbin/init</p><p>说明</p><p>–privileged=true<br>/usr/sbin/init<br>这两行主要解决容器中使用systemctl去启动服务时出现D_Bus错误的问题</p><p>-d: 后台运行<br>-it: 组合使用，创建一个伪终端<br>-p: 端口映射，本机端口：容器端口<br>–name: 容器名，（需要注意命名规范，可自己定义 ，only [a-zA-Z0-9][a-zA-Z0-9_.-]）<br>-e：防止乱码，编码格式<br>最后跟上下载下来的镜像名</p><p>镜像启动成功后会返回一串id号，特别长</p><p>通过 docker ps –a查看当前docker 中哪些容器正在运行</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.47.12.png" srcset="/img/loading.gif" alt="img"></p><p>第一次初始化的时候，使用run，后来都是用start</p><p>docker start  container Id</p><p>启动后，在次进入docker exec -it  id bash</p><p>重启docker restart id</p><p>停止docker stop id</p><p>删除docker rm id</p><p>注意：删除前需要停止镜像</p><p>四、安装容器内运行环境</p><p>根据所需要的开发项目进行环境搭建，与一般机器配置无异，如果需要图形化界面需要另外安装插件</p><p>由于本人需要运行django项目，所以配置的环境主要是</p><p>Django==1.8.2<br>mysql-connector-python==8.0.12<br>mysqlclient==1.3.13<br>Pillow==5.2.0<br>protobuf==3.6.1<br>six==1.11.0<br>uWSGI==2.0.17.1<br>nginx:<br>nginx version: nginx/1.12.2</p><p>Mysql的坑和uwsgi的坑，请看下面专门描述的坑点</p><p>五、主机与容器间资源传输</p><p>Windows机器与容器间传输文件，由于是文本界面，无法像图形界面一样使用CV大法，一切靠命令</p><p>直接上代码</p><p>sudo docker cp txcrm2:/home/log/production.log /system/logs     ##仔细看 txcrm2是镜像id ，后面就是文件路径以及复制到宿主机的文件路径</p><p>从主机复制到容器sudo docker cp host_path containerID:container_path</p><p>从容器复制到主机sudo docker cp containerID:container_path host_path</p><p>最后拷贝到本地使用scp</p><p>六、容器安装+配置 uwsgi</p><p>安装uwsgi确实花了点功夫，都在处理些奇怪的坑，但好在已经配完，遇到的坑在后面进行了描述</p><p>配置uwsgi</p><p>进入的项目文件夹，新建一个uwsgi.ini的配置文件</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.49.42.png" srcset="/img/loading.gif" alt="img"></p><p>启动uswsgi  uwsgi –ini uwsgi.ini</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.50.50.png" srcset="/img/loading.gif" alt="img"></p><p>这里也有一点小坑，就是你在启动uwsgi的时候，会在当前所在目录去创建uwsgi.pid和uwsgi.log，这个可以能过uwsgi的配置文件去固定一个位置进行保存</p><p>Uwsgi 停止</p><p>Uwsgi –stop uwsgi.pid</p><p>可以通过浏览器直接访问测试uwsgi是否启动成功</p><p>七、容器安装+ 配置nginx</p><p>Nginx安容易多了。直接使用yum install nginx就可以安装成功</p><p>Nginx start /etc/nginx/nginx.conf  启动</p><p>Nginx stop  停止</p><p>Nginx –s reload 重启nginx服务</p><p>配置nginx</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.56.11.png" srcset="/img/loading.gif" alt="img"></p><p>Upstream  主要用来做负载均衡</p><p>其中  location 是定义路由，如果使用location = /  是属于精准匹配，不加 = 就相当于正则匹配   proxy_pass 转发服务到哪里， 后面拼接一定要加上http://  否则也是不成功的，这里要注意，缩进无所谓，能看明白就行，但语法千万不能错，一个单词错就没法启动了（本人粗心大意在这里出了错）</p><p>如果出错：可以使用 systemctl status nginx.service查看错误信息</p><p>静态文件nginx是无法从项目中获取的。需要 自己创建静态文件夹，项目中使用python manage.py collectstatic</p><p>八、负载均衡</p><p>这里其实就是在upstream 当中加入多一条server信息，nginx会自动进行选择转发</p><p>九、Docker提交保存镜像</p><p>1、保存：docker commit  镜像id 自定命名，  保存自定义名时最好保存格式为：账户名/镜像名   方便上传时不需要再更改</p><p>2、登录docker login</p><p>一般如果在软件中已经登录，这里可以不用登录了，可以当成验证是否成功登录check一下</p><p>3、如果是第一次准备上传镜像需要先到 hub.docker.com中登录创建一个镜像仓库</p><p>PS:全英文环境，E文不好的朋友可以用chrome的翻译功能，大致没毛病</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.58.58.png" srcset="/img/loading.gif" alt="img"></p><p>按照步骤一步步操作就好了</p><p>3、上传自定镜像</p><p>首先查看一下本地的镜像有哪些</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%889.59.50.png" srcset="/img/loading.gif" alt="img"></p><p>docker push 镜像名：tags</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%8810.00.54.png" srcset="/img/loading.gif" alt="img"></p><p>出现进度条，就成功了，等待就可以</p><p>十、坑点</p><p>1、windows下docker下载，需要注册</p><p>2、通过nginx转发时，会丢失掉端口的问题</p><p><a href="http://elim.iteye.com/blog/2286952" target="_blank" rel="noopener">http://elim.iteye.com/blog/2286952</a>，</p><p>在配置nginx时，server内设置：</p><p>proxy_set_header Host $host，</p><p>host是不带端口号的，将其改为proxy_set_header Host $host:805，问题得以解决，其中805是docker容器映射到本机的端口</p><p>3、安装环境时，mysql-python是不支持python3的，所以需要更换其它方式来进行数据库交互工作（在这个地方折腾了很久）</p><p>我在这里使用了mysql官方提供的  mysql-connect-python  和 mysqlclient</p><p>还可以安装pymysql</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%8810.02.59.png" srcset="/img/loading.gif" alt="img"></p><p>将项目的初始化文件中加入</p><p>Import pymysql</p><p>Pymsql.install_as_MySQLdb()</p><p>更改连接方式使用pymsql进行连接</p><p>另外最好使用离线包安装mysql</p><p>4、安装uwsgi</p><p>安装uwsgi的时候，使用pip3 install uwsgi   明明是已经安装完成，显示安装成功，pip freeze也可以看到安装的版本号，仍然提示uwsgi命令无法找到，多次测试之后还是不行。最后去到uwsgi的安装目录下面查看，确实已经安装成功，而且目录下面是可以启动的，为了方便，做了了软链接，测试成功，这里安装uwsgi使用的是离线包安装</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%8810.03.54.png" srcset="/img/loading.gif" alt="img"></p><p>5、用docker运行service 时会报错，centos中服务启动和关闭使用systemctl</p><p>但是，问题在于使用docker 的时候，systemctl是用不了的，需要在run时加入两条命令，说实话原理我没搞懂，反正把问题解决就行了</p><p>加入的命令是：</p><p>–privileged=true<br>/usr/sbin/init<br>这两行主要解决容器中使用systemctl去启动服务时出现D_Bus错误的问题</p><p>重新启动容器就正常了</p><p>6、无关docker的坑…… 在项目中生成静态文件时出的错，也提一下</p><p>使用python manage.py collectstatic的时候确认要求输入 yes or no，自己傻输入的是y, 然后、、、、就傻了</p><p><img src="http://47.93.248.15/wp-content/uploads/2018/10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-10-10-%E4%B8%8A%E5%8D%8810.04.55.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>docker</tag>
      
      <tag>Django</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scrapy-1-快速入门</title>
    <link href="undefined2017/01/26/scrapy-1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>2017/01/26/scrapy-1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本教程环境是在Mac下正确安装的，windows下各个操作系统没有测试过</p><p>在学习前需要了解scrapy能干什么</p><p>1、scrapy的设计全部采用异步请求，能够全面提高爬取抓取速度</p><p>2、自动配置了重复请求过滤的操作</p><p>3、可以通过命令行参数，默认导出json，csv等格式，Excel需要自己实现</p><p>4、通过管道下载文件</p><p>注：scrapy创建工程和运行程序，都是需要通过终端来完成的，无法通过可视化界面来创建</p><p><strong>一、基本入门</strong></p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>安装有可能会出错，更新一下pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><p>在终端中输入python回车，输入一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import scrapyscrapy.version_info</span><br></pre></td></tr></table></figure><p>以上编译通过不报错即可</p><p>创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject demo</span><br></pre></td></tr></table></figure><p>demo是你工程的名字,默认创建在你当前终端所在的路径上</p><p>为了方便后续开发，可以使用pycharm打开这个工程</p><p>spider文件夹下创建爬虫文件bookspider.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItcastSpider</span><span class="params">(scrapy.spiders.Spider)</span>:</span>     </span><br><span class="line">    name = <span class="string">'book'</span>     </span><br><span class="line">    start_urls = [<span class="string">'http://books.toscrape.com/'</span>]     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self,response)</span>:</span>         </span><br><span class="line">        print(<span class="string">"收到数据"</span>)</span><br></pre></td></tr></table></figure><p>说明其中几点</p><p>name是这个爬虫的名字，一个scrapy可以有多个爬虫项目，启动时候也是这个name为标记</p><p>start_urls是其实url，默认回调是parse函数，是获得的结果</p><p>parse中的response  是获得的html结果</p><p>运行爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books</span><br></pre></td></tr></table></figure><h6 id="运行后，会打印response"><a href="#运行后，会打印response" class="headerlink" title="运行后，会打印response"></a>运行后，会打印response</h6><p>以下内容简单介绍，后续有实际案例</p><p><strong>如何爬取下一页内容</strong></p><p>如果继续向下爬取，需要通过在parse中调用yield scrapy.Request(next_url,callback=函数名)</p><p>实际上就是通过协程来进行处理的，比如next_url爬取的下一页地址，callback函数名是调用parse则使用parse进行解析，这样就形成了循环爬取每一页了</p><p><strong>如何解析内容</strong></p><p>css方法可以获得样式的节点，respose.css(myclass)</p><p>任何节点都可以使用xpath进行读取，extract_first获得的是第一个内容值</p><p><strong>如何保存数据</strong></p><p>解析html的数据，比如name和price，组装成字典，通过yield返回，这里后面会用到item进行包装数据的</p><p>但是返回到哪里了?实际上是返回到item中进行处理了</p><p><strong>如何输出数据</strong></p><p>在运行终端命令时候通过增加参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl books  -o books.csv</span><br></pre></td></tr></table></figure><p>通过-o books.csv会自动把通过yield返回的item保存到到books.csv中</p><p>以上是通过纯粹终端命令行的方式来运行的</p><p>如果要使用pycharm来启动调试，则需要在程序内创建run.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line">execute([<span class="string">'scrapy'</span>,<span class="string">'crawl'</span>,<span class="string">'books'</span>,<span class="string">'-o'</span>,<span class="string">'books.csv'</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>scrapy-1-快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>scrapy</tag>
      
      <tag>scrapy-1-快速入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-打包exe</title>
    <link href="undefined2016/05/02/Python-%E6%89%93%E5%8C%85exe/"/>
    <url>2016/05/02/Python-%E6%89%93%E5%8C%85exe/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-5-打包exe"><a href="#Python-5-打包exe" class="headerlink" title="Python-5-打包exe"></a>Python-5-打包exe</h1><p>通过这篇文章，你能学习到以下内容</p><p>1、使用pyinstaller进行打包</p><p>打包exe文件,使用pyinstaller，pyinstaller支持python2和python3</p><p>目前存在问题:</p><p>1、pyinstaller 打包是在什么环境下打包，可以在什么环境下执行，无法在Mac下打包exe</p><p>2、执行后大量占用内存，最后无法执行完成(有待修复)</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line">pip install --upgrade pyinstaller</span><br></pre></td></tr></table></figure><p>将cmd的目录切换至（命令：cd 文件路径(注意空格)）需要打包的py文件目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F MyTools.py</span><br></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">–icon=图标路径</span><br><span class="line">-F 打包成一个exe文件</span><br><span class="line">-w 使用窗口，无控制台</span><br><span class="line">-c 使用控制台，无窗口</span><br><span class="line">-D 创建一个目录，里面包含exe以及其他一些依赖性文件pyinstaller </span><br><span class="line">-h 来查看参数</span><br></pre></td></tr></table></figure><p>回车后，直到操作结束。<br>返回目标文件目录，发现该目录下生成了.spec文件test.spec：<br>打包好的exe文件，在同目录的dist文件中：<br>my.ico 是一个图标名，和当前的test.py文件在同一个目录下</p><p>需要注意的是如果读取文件，需要修改相应代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(sys.argv[<span class="number">0</span>])<span class="comment">#当前文件路径</span></span><br><span class="line">path =os.path.dirname(sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> (path)<span class="comment">#上一级目录</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(path):    </span><br><span class="line"><span class="keyword">if</span> filename.find(<span class="string">".xlsx"</span>) &gt;= <span class="number">0</span>:        </span><br><span class="line">    print(<span class="string">"正在读取数据文件~%s"</span>%filename)        </span><br><span class="line">        readExcel(path+<span class="string">'/'</span>+filename)<span class="comment">#读取了数据        </span></span><br><span class="line">        print(<span class="string">"读取数据完成。。。开始梳理数据中"</span>)        </span><br><span class="line">        <span class="comment">#循环所有key        </span></span><br><span class="line">        allresult_arr=[]        </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dicdata:            </span><br><span class="line">            result_arr= handle_data(dicdata[key],key)              </span><br><span class="line">            allresult_arr.append(result_arr)        </span><br><span class="line">            print(<span class="string">"准备开始写入数据"</span>)        </span><br><span class="line">            writetoexcel(allresult_arr)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>